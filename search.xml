<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[从客户端的角度设计后端的接口]]></title>
      <url>/android/2019/08/10/%E4%BB%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%A7%92%E5%BA%A6%E8%AE%BE%E8%AE%A1%E5%90%8E%E7%AB%AF%E7%9A%84%E6%8E%A5%E5%8F%A3l/</url>
      <content type="text"><![CDATA[前言  兵马未动，粮草先行。在一款APP产品的各个版本迭代中，兵马的启动指的是真正开始敲代码的时候，粮草先行则是指前期的需求，交互，UI等评审准备阶段，还有本文要说的接口的设计与评审。虽然很多时候一个api接口的业务，数据逻辑是后端提供的，但真正使用这个接口的是客户端，一个前端功能的实现流程与逻辑，有时候只有客户端的RD才清楚，从某种意义来说，客户端算是接口的需求方。所以建议在前期接口设计和评审时，客户端的RD应该更多的思考和参与，什么时机调什么接口？每个接口需要哪些字段？数据含义怎么给？只有这些都考虑清楚，且达成一致并产出接口文档后，当项目真正启动时，根据接口协议进行开发，才能尽量避免各种不确定因素对项目整体进度的影响。本文介绍了接口设计中常见的规范，以及个人的一些思考与总结，水平有限，权当是抛砖引玉，如果有更好的设计，请在文章下方留言告诉我，谢谢。接口设计规范一.  接口示例  以下是一个用户信息接口的文档示例，包含接口描述，请求参数，响应参数，json示例等。接口描述：用户登陆成功后，或进入个人中心时会获取一次用户信息            URI      方法                  /userinfo      GET      请求参数            名称      必填      备注                  id      是      用户id      响应参数            名称      类型      备注                  id      String      用户id              name      String      姓名，例：张三              age      String      年龄，例：20      json示例{    "code":200,    "msg":"成功",    "time":"1482213602000",    "data": {        "id":"1001",        "name":"张三",        "age":"20"    }}二.  基本规范1.通用请求参数  每个请求都要携带的参数，用于描述每个请求的基本信息，后端可以通过这些字段进行接口统计，或APP终端设备的统计，一般放到header或url参数中。            字段名称      说明                  version      客户端版本version，例：1.0.0              token      登陆成功后，server返回的登陆令牌token              os      手机系统版本（Build.VERSION.RELEAS）例：4.4，4.5              from      请求来源，例：android/ios/h5              screen      手机尺寸，例：1080*1920              model      机型信息（Build.MODEL），例：Redmi Note 3              channel      渠道信息，例：com.wandoujia              net      APP当前网络状态，例：wifi，mobile；部分接口可以根据用户当前的网络状态，下发不同数据策略，如：wifi则返回高清图，mobile情况则返回缩略图              appid      APP唯一标识，有的公司一套server服务多款APP时，需要区分开每个APP来源      2.请求Path，http://www.online.com/api/ [path]  原则：在以下命名规范的基础上尽量保持良好的可读性，见名知意。另外这里需要额外提下restful规范，个人理解restful规范是通过path表示当前请求的资源，通过method表示当前请求的操作动作（post=增，delete=删，put=改，get=查），例：GET  /userinfo/{id}，通过这个path就可以清楚的知道当前请求的意图是根据id获取用户信息，而APP开发中很多时候一个页面是需要同时获取，如，用户，订单，营销各种信息，这时候就很难用一个path来表示当前请求的真正意图，restful规范就很难得到实现，有不同见解的欢迎交流。故本文介绍的接口设计方法，只区分get和post，通过path命名定义请求行为，            操作行为      Method      Path                  查找      GET      getXxx              增加      POST      addXxx/submitXxx              修改      POST      modifyXxx              删除      POST      delXxx      示例            操作行为      Method      Path                  获取用户信息      GET      getUserInfo              增加收货地址      POST      addAddress              修改密码      POST      modifyPwd              删除收货地址      POST      delAddress              登陆      GET      login              发送短信验证码      GET      sendSms              订单支付      POST      orderPay      3.响应数据            字段名称      说明                  code      响应状态码，200：成功；非200：失败              msg      请求失败时的message              time      服务端时间戳，单位：毫秒。用于同步时间              data      数据实体      code=200时，msg=登陆成功/修改成功/提交成功；如果需要Toast，可以直接使用msg。code!=200时，msg=错误提示信息；比如login接口，”账号或密码错误”，”账号不存在”类似这些的业务提示文案放在msg字段，客户端直接Toast就可以了。不过需要提醒后端同学，错误提示不能自己觉的什么合适就提示什么，要按需求文档来提供，或和PM确认。  object类型数据// json{  "code":200,  "msg":"成功",  "time":"1482213602000",  "data": {    "name":"张三",    "age":"20"  }}       // model.javapublic class Model {     public String name;     public String age;}   array类型数据，正常情况下在解析json的时候，1.先解析code和msg，判断code==200的情况下继续解析data。2.将data下面的json串解析成当次请求需要的model数据结构。对于array类型的数据，即使只有1个list字段，也要保证data下是个完整的object结构，这样我们在用Gson解析model的时候，统一将data层级下的数据当object解析就可以了，不用区分object或array的情况。// json{    "code":200,    "msg":"成功",    "time":"1482213602000",    "data": {        "list":["张三","李四"]    }}     // model.javapublic class Model {    public List&lt;String&gt; list;}   array+分页类型数据，需要额外返回total字段，客户端需要通过total判断本地加载的list是否还有更多可以加载。请求参数            名称      必填      备注                  pageNum      是      当前第几页，例：1，2，3              pageSize      是      每页条数，例：10      响应数据// json{    "code":200,    "msg":"成功",    "time":"1482213602000",    "data": {        "list":["张三","李四"],        "total":"10"    }}     // model.javapublic class Model {    public List&lt;String&gt; list;    public String total;}   不论列表页面是支持分页加载，还是一次加载全部数据，都建议将接口设计成支持分页的，如果要实现一次性加载只要把pageSize改成类似Integer.Max的值。这样设计的好处是客户端和后端可以设计一套统一的分页列表模版代码，即使需求变更，也可以很好的支持。4.命名规范      统一命名：与后端约定好即可（php和js在命名时一般采用下划线风格，而Java中一般采用的是驼峰法），无绝对标准，不要同时存在驼峰”userName”，下划线”phone_number”两种形式就可以了。        避免冗余字段：每次在新增接口字段时，注意是否已经存在同一个含义的字段，保持命名一致，不要同时存在”userName”，”username”，”uName”多种同义字段。        注释清晰（重要）：每个接口/字段都需要有详细的描述信息，很多时候接口体现业务逻辑，是团队中很重要的文档沉淀，同时，详细的接口文档，可以帮助新人快速熟悉业务。具体示例如下：    接口描述：用户登陆成功后会获取一次用户信息，每次进入个人中心也会重新获取一遍            URI      方法                  /userinfo      GET        字段描述：数值要有单位，时间要有格式，状态字段要有状态描述，以及不同状态下对于其他字段返回逻辑的关联关系。            字段类型      字段名称      说明                  Boolean      isVip      是否时Vip用户，1：是，0：否              金额      realPay      订单实际付款金额，单位：元              时间      payTime      订单付款时间，单位：毫秒              日期      payDate      订单付款日期，格式”yyyy-MM-dd”              状态      status      订单状态，1：进行中（payDate不返回），2：待支付（payDate返回），3：已支付（payDate不返回）；（bool以1/0表示，状态从1+开始）      5.统一定义String字段类型// json{    "name":"张三",    "isVip": true,    "age":20,    "money": 10.5}   // Model.javapublic class Model {    String name;    boolean isVip;    int age;    float money;}  如果使用的是Gson库的话，正常情况下这么定义model是可以正常解析，但是会有以下异常情况：  Boolean型字段{    //如果传true，false以外的数据，就会解析失败    "isVip": 20    "isVip": }解析报错：（1）java.lang.IllegalStateException: Expected a boolean but was NUMBER（2）com.google.gson.stream.MalformedJsonException: Unexpected value  Int类型字段{    "age": 20.5    "age": abc    "age": ""    "age": }解析报错：（1）java.lang.NumberFormatException: Expected an int but was 20.5（2）java.lang.IllegalStateException: Expected an int but was STRING（3）java.lang.NumberFormatException: empty String（4）com.google.gson.stream.MalformedJsonException: Expected value  Float类型字段{    "money": abc    "money": ""}解析报错：（1）java.lang.NumberFormatException: For input string: "abc"（2）java.lang.NumberFormatException: empty String  Gson库在解析到某个非法字段时，会抛出各种异常，导致整个model的解析失败。客户端没处理好的话，会因为这种时不时的脏数据引发各种奇怪的bug。解决方案：  修改Gson源码，对于字段解析失败的异常进行捕获，保证model解析完成，非正常解决方案，修改源码后Gson库就不能随便更新了，获取替换其他json解析库也变的不方便。  自定义JsonDeserializer，比较正常的解决思路。public class IntegerDefaultAdapter implements JsonDeserializer&lt;Integer&gt; {  @Override  public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)      throws JsonParseException {                // 如果integer类型的字段，进行一次类型转换      try {          return Integer.parseInt(json.getAsString());      } catch (NumberFormatException e) {      }      return -1;  }}   String json = "{name:listen,isVip:true,age:abc,money:1.0}";Gson gson = new GsonBuilder().registerTypeAdapter(int.class, new IntegerDefaultAdapter()).create();Model model = gson.fromJson(json, Model.class);// age字段解析出来为-1  将APP接收数据的类型定义为容错能力更强的String（推荐）。{    "name": "abc"    "name": "20"    "name": "10.2"    "name": "true"}优点：  容错性强，规避因脏数据引起的数据解析失败。  age，money这些字段大部分情况下都是直接展示，此时便可省去拼接 ““，或String.valueOf()等步骤。另外假设此时将age字段定义为int类型，很容易就会直接调用textView.setText(age)，那么这个age就会当成resId去执行，导致资源找不到报错，定义为String可以避免此类错误。注意事项：      Boolean类型数据，统一返回1（true）和0（false），客户端做一层容错判断，只有1才为true，其他非1，解析失败的情况均为false，例：    if(!TextUtils.isEmpty(isVip) &amp;&amp; "1".equals(isVip)) {        return true;} else {        return false;}            status类型字段从1+开始，和Boolean类型（0否，1是）区分开。”0”的含义有2种，（1）非0即为真，所以0即表示false；（2）”0”是一种未赋值的默认状态。假设此时用0表示状态1，那么就很难判断出到底时数据解析失败，使用默认值0，还是说逻辑走通并赋值为0。例：orderStatus，1:进行中，2:待支付，3:已完成。        int，float类型数据，如果不是直接展示的话，需要做一次类型转换，注意捕获异常，在解析失败的情况下，使用default值。    int defaultInt = -1;try {    defaultInt = Integer.parseInt(age);} catch (NumberFormatException e) {    e.printStackTrace();}return defaultInt;      6.上传/下载接口，根据md5校验数据完整性  上传，下载文件/图片时，除了file本身，还要携带该file的md5，在传输过程中可能丢失部分数据，导致文件损毁，所以需要通过md5值进行完整性校验。      上传成功后，正常情况后端只需要返回code表示成功/失败，在开发阶段，可以让后端将上传成功后的图片url返回，这样当我们调用完接口以后，就可以通过该url字段查看图片是否上传成功，存储的尺寸大小，模糊度等，就不用每次粘着后端帮忙看请求结果了，这个思路同样通用于其他接口，不过上线后需要将这个不必要的字段去掉。      {      "code":200,      "msg":"成功",      "time":"1482213602000",      "data": {          "url":"http://www.online.com/path/pic.jpg"      }  }      7.避免浮点型计算  浮点型计算可能导致精度丢失，为了避免，可以缩小单位进行存储。例：1.5元，后端会以150分存到数据库，1.5km会存成1500m。同理，如果一个类似距离的字段，如果是展示用，则直接返回”1.5km”，如果涉及到逻辑判断与计算（如：&gt;1000m，执行逻辑A，&gt;1500m，执行逻辑B），可以返回”1500，单位(m)”，至少比传1.5来的方便。当然如果要计算浮点型也是可以的，需要用到BigDecimal，这么设计只是为了减少出错的可能性。8.json数据保持良好结构{    "userId"...    "userName"...    "userPhoto"...    "orderId"...    "orderType"...    "addressId"...    "addressName"...    "addressDetail"...}  json的3类信息user，order，address，全部堆在一起，字段多了以后，对于接口信息的读取很不直观；客户端在定义model的时候，会将全部字段定义在一个model中，如果其他地方也有用到addressId，Name，Detail等字段信息，则需要重新定义address的model，无法实现model的复用。{    "user":{        "id"...        "name"...        "photo"...    }    "order":{        "id"...        "type"...    }    "address":{        "id"...        "name"...        "detail"...    }        }  经过优化后user，order，address字段在各自的结构体内，一眼就可以看出这个接口有哪些类型的数据。还有点要注意，如果放在同一级别，id字段就需要用userId，orderId，addressId区分开，而现在根据不同结构体区分字段类型后，直接使用id就可以了，如果还使用userId，写代码的时候就会出现data.getUser().getUserId()的写法，就会很奇怪。三. 瘦客户端  众所周知，客户端任何的修改都是需要发版的，特别是IOS需要走AppStore的审核流程。为了修一个bug，仅仅改几行代码，而重新走一轮发版流程，是很劳民伤财的。所以在接口设计的时候，也需要适当考虑这点，将业务重心交由后端，客户端保持逻辑简单。有时候，一个功能，客户端，后端都可以做，那么为什么客户端就是不做，要后段拼好提供呢？还是那句话，后端一天可以发n个版，客户端一个版本却只能发一次，有些团队一开始并没意识到这点，总觉后端就是重度业务逻辑的所在，管那么多前端的展示，字符串拼接逻辑干嘛，可是，真正到了出问题（bug或需求变更）需要发版的时候，虽然70%的锅是客户端背，但是，剩余30%也会对当初重客户端的选择而后悔，不过重点不是谁背锅，而是产品不出问题。so，为了大局，后端的RD们，我们得聊聊。  客户端尽量只负责展示逻辑，不处理业务逻辑  例如：客户端有个TextView，后端只给个status字段，status=1时，展示文案1；status=2时，展示文案2；这样设计的缺点是，如果以后要修改status=3时，展示文案1，那么这个status判断逻辑时写死在客户端，就没办法支持这种修改，且这种设计限定死了TextView只能展示2种文案。推荐方案是后端直接将TextView需要展示的文案下发，这样不管是status的判断，还是文案的展示，后期都是可变的。  客户端不处理金额的计算  例如：外卖APP，用户在下单的时候，需要选择收货地址，支付类型，优惠券等，任何一个选项的修改，都可能影响用户最后需要支付的金额。所以这里比较常见的接口设计是在每次选择完回到订单支付页面后，再发送一次请求，后端根据当前选项重新计算金额。金额永远是一款产品最重要，最敏感的信息，如果交由客户端计算，万一出错，即使少1分，都是毁灭性的，所以，关于金额，展示就好。  客户端少处理请求参数的校验与约束提示          例如：修改密码功能，密码规则”6-12字母，数字，下划线”，有3种做法：        在发送请求前，客户端校验密码规则，如果不符合，则不发送请求。优点：规则不满足时，可以减少不必要的请求。缺点：客户端写死校验逻辑，密码规则变化时，客户端需要发版。  客户端只判断null，和最短位数限制，其他校验规则交由后端处理。优点：灵活性最好。缺点：后端压力大，校验请求多。  后端在通用配置的接口返回正则表达式，客户端获取后进行正则校验。优点：具有一定灵活性。缺点：开发，调试成本较高。（推荐：即使出问题，也可以清除配置，回退到第2个方案）四.扩展性  接口的设计要具有一定的扩展性，考虑到后续版本变化，对于接口，字段的影响及变化。  文案与图片          对于界面上的文案，图片，特别是”xxx20分钟之内”，”xxx7天到期”这些带数字的文案，不可能永远不变的，即使和PM确认了打死不变，也最好通过常量配置接口进行下发（未下发时使用APP本地默认文案，下发时使用下发的文案），我们的原则是：变与不变都能支持。        数据列表化：尽量用List(key, value)的数据格式定义类似列表的界面[图片上传失败…(image-c3ec04-1567729875255)]方案1：客户端在写xml的时候将左侧的”姓名”，”性别”，”年龄”写死，右侧的具体数据从json解析获得{    "name": "张三",    "sex": "男",    "age": "20岁",    "nickName": "小张"}方案2（推荐）：将左侧的title和右侧的value，以list(key-value)的数据形式进行下发，优点：左，右侧文案灵活配置，后期如果需要扩展，新增或删除一个条目，都可以通过后端控制。不过采用这种形式，也需要考虑实际场景，对于变化不那么频繁，数据item较少，较固定的情况下其实没有必要设计的太灵活，只会增加开发成本。{    "userInfos":[    {        "key":"姓名",        "value":"张三"    },{        "key":"性别",        "value":"男"    },{        "key":"年龄",        "value":"20岁"    },{        "key":"昵称",        "value":"小张"    }]}3.用flag替换boolean：一般情况下，一款APP都会有config接口，用于获取一些常量文案，通用配置等信息，会有很多类似开关的字段，如：”isNew”，”isVip”，”isShowBalance”等等。{    "isNew":"1",// 是否是新用户    "isVip":"1",// 是否是VIP用户    "isShowBalance":"1",//是否显示侧边栏余额模块}优化方案：通过二进制第1位表示”isNew”，二进制第2位表示”isVip”，二进制第3位表示”isShowBalance”。如果有其他新增状态，不需要新增字段，就需要改变返回的数据即可。{    "flag":"7"// 二进制：111，表示3个状态都为true    "flag":"5"// 二进制：101，表示isNew，isShowBalance为true，isVip为false}long flag = 5;System.out.println("bit=" + Long.toBinaryString(flag));System.out.println("isNew=" + ((flag &amp; 1) == 1));System.out.println("isVip=" + ((flag &amp; 2) == 2));System.out.println("isShowBalance=" + ((flag &amp; 4) == 4));  bit=101isNew=trueisVip=falseisShowBalance=true五.安全性  响应数据中包含用户隐私的字段数据，需要加*号。如：手机号，身份证，用户邮箱，支付账号，邮寄地址等。{    "phone":"150*****000",    "idCard":"3500**********0555",      "email":"40*****00@qq.com"     }      请求参数中包含用户隐私的字段参数，如：登陆接口的密码字段，需要进行加密传输，避免被代理捕捉请求后获取明文密码。        客户端和服务器通过约定的算法，对传递的参数值进行签名匹配，防止参数在请求过程中被抓取篡改。密钥记得放到so中，放在java层太不安全，so中要进行keystore反向签名校验，避免so被获取后直接调用获取算法。                  so中要进行keystore反向签名校验                  Java层在进行参数签名计算的时候需要获取app本地存储的密钥，调用NativeHelper.getKey()，在so中通过反射调用java层的getSignature()，比较是否和so中存储的keyStore哈希值一致，如果是则返回密钥，不是则返回空字符串。                Java层的NativeHelper.java          package com.listen.test;  public class NativeHelper {      static {          System.loadLibrary("native-lib");      }      // 调用so获取密钥      public native String getKey();              // 获取当前keyStore的hash值      public String getSignature() {          final String packname = BaseApplication.getInstance().getPackageName();          PackageInfo packageInfo;          try {              packageInfo =                  BaseApplication.getInstance()                      .getPackageManager()                      .getPackageInfo(packname, PackageManager.GET_SIGNATURES);              Signature[] signs = packageInfo.signatures;              Signature sign = signs[0];              return sign.hashCode() + "";          } catch (Throwable t) {              if (null != t) {                  t.printStackTrace();              }          }          return "";      }  }                so层的native-lib.c                   // 字符串转字符           char* _JString2CStr(JNIEnv* env, jstring jstr) {              char* rtn;              jclass clsstring = (*env)-&gt;FindClass(env, "java/lang/String");              jstring strencode = (*env)-&gt;NewStringUTF(env, "GB2312");              jmethodID mid = (*env)-&gt;GetMethodID(env, clsstring, "getBytes",                      "(Ljava/lang/String;)[B");              jbyteArray barr = (jbyteArray)(*env)-&gt;CallObjectMethod(env, jstr, mid,                      strencode); // String .getByte("GB2312");              jsize alen = (*env)-&gt;GetArrayLength(env, barr);              jbyte* ba = (*env)-&gt;GetByteArrayElements(env, barr, JNI_FALSE);              if (alen &gt; 0) {                  rtn = (char*) malloc(alen + 1); //"\0"                  memcpy(rtn, ba, alen);                  rtn[alen] = 0;              }              (*env)-&gt;ReleaseByteArrayElements(env, barr, ba, 0);              return rtn;          }                       char* storeKeyHash = "1234567890";// 该值可以通过java层的getSignature获取                            JNIEXPORT jstring JNICALL Java_com_listen_test_NativeHelper_getKey(                  JNIEnv *env, jobject obj, jbyteArray array) {              // 反射获取当前keyStore的hash值              jclass jClazz = (*env)-&gt;FindClass(env, "com/listen/test/NativeHelper");              jmethodID jmethodid = (*env)-&gt;GetMethodID(env, jClazz, "getSignature",                      "()Ljava/lang/String;");              jstring appSign = (jstring)(*env)-&gt;CallObjectMethod(env, obj, jmethodid);                              // 判断是否是本程序的签名哈希值              char* charAppSign = _JString2CStr(env, appSign); //将jstring转换为cha*              if (strcmp(charAppSign, storeKeyHash) != 0) {                  return (*env)-&gt;NewStringUTF(env, "");//keyStore的hash不一致，不是在当前app种调用该so              }              return (*env)-&gt;NewStringUTF(env, "秘钥值");//keyStore的hash一致，返回密钥          }                    六.兼容性  APP1.0在使用接口A，如果此时在开发1.1的时候修改了接口A的逻辑，在1.1发版的时候线上就会出现2个版本的客户端访问同一个接口A，为了保证1.0客户端调用接口A不会出错，就需要通过version字段或path中的”v1/login”，”v2/login”进行区分，不同版本客户端访问同一接口时处理逻辑要各自独立。  接口/字段的删除，修改要谨慎：          对于已经存在的接口进行修改，需要考虑对线上版本的影响，尽量是数据含义，和新增字段，而不是去修改。        md5缓存的兼容性：          如果1.0的接口A存在md5缓存，正常都是后端上线后再发布1.1客户端的顺序，如果在后端上线后，1.1还没发布的情况下，此时1.0的客户端就缓存了1.1后端逻辑的md5，在更新成1.1的时候，md5没有变，就有可能缓存的还是1.0的数据，所以比较推荐后端在计算md5的时候把version加上，这样更新APP可以保证md5是不一样的。      七.性能优化  合并接口          为了减少客户端和服务器建立连接和断开连接消耗的时间，资源，电量，尽量避免频繁的间隔网络请求。业务场景允许的情况下，尽量1个页面对应1个接口。原先一个页面要通过多个请求获取多种类型数据的情况，最好能通过一个接口全部获取得到。又如：在调用B接口前需要A接口的前置数据的情况，可以让后端支持下，在调用A接口时直接返回B接口的数据，减少类似这种的连续请求。        字段精简          定义字段名时，在保证良好可读性的前提下，尽量精简，减少流量的消耗         {   "orderDescription" &gt;&gt; "orderDesc"   "oldPassword" &gt;&gt; "oldPwd"   "longitude" &gt;&gt; "lng"   "latitude" &gt;&gt; "lat" }        md5缓存          对于频繁调用，且数据不常变化的接口（config配置接口），可以在返回的数据中添加md5字段（用于校验除md5外其他数据是否变化），在下次请求的时候将这个md5作为参数传给后端，md5没有变化的情况下，不返回data，客户端可以直接使用上次请求缓存在本地的data。      [图片上传失败…(image-8207fa-1567729875255)]  无用字段清理          每个版本的接口更新后，需要将无用字段进行清理。或者同个接口不同状态下需要返回的字段各不相同的时候，当次请求不需要的字段需要提醒后端不必下发，避免传输无用数据浪费用户流量。        图片裁剪服务          客户端上传图片后，当需要在列表这些图片区域较小的地方展示的时候，没必要直接加载原图，可以先在后端通过图片裁剪服务处理后再进行展示。例：http://image-demo.img-cn-hangzhou.aliyuncs.com/example.jpg@100h_100w_1e_1c?spm=5176.doc32223.2.3.jmkKF9&amp;file=example.jpg@100h_100w_1e_1c， 这是阿里云的图片裁剪服务，在url后面直接拼上裁剪参数，就可以实现将原图居中裁剪成100*100的缩略图。当需要展示高清图的时候，再加载原图的url。        局部刷新          一个页面，如果之前已经加载了20%的数据，那么就不需要每次都返回100%数据，只要返回剩余80%即可。例：订单列表页面，每个item已经具有类似orderId，orderDesc等字段，那么点击进入订单详情的时候，orderId，orderDesc就可以从订单列表传递过来即可，详情页的请求只需要返回订单相关的剩余数据，客户端需要额外处理数据组装逻辑，将前一个页面传递过来的字段和详情页请求到的字段组装成完整的model数据。        wifi与移动网络的区别对待          WiFi连接下，网络传输的电量消耗要比移动网络少很多，应该尽量减少移动网络下的数据传输，多在WiFi环境下传输数据。例：crash日志上报，数据统计接口等，可以在移动网络的情况下请求频率降低，或缓存，在wifi网络时上调请求频率，或将缓存的数据统一上报。还有上文提到的，如果是wifi网络状态下，就下发高清图提升用户体验，移动网络状态就下发缩略，或裁剪图。      八.体验优化  设计接口时，不能只考虑减少流量消耗，性能优化等，特定场景下用户体验的优化才是最高优先级的。  通过预加载降低对网络的依赖          使用APP的场景为网络较差的情况。例：配送员在使用配送APP的时候，商家地址如果在地下室，或配送员进入电梯的时候，这时候常要查看订单详情，网络信号又比较差的，就会影响正常工作。可以考虑在订单列表的接口中，将订单详情的数据一起请求下来，并通过md5判断详情页面数据是否变化，避免重复加载，这样其实用户在网络比较好的情况下请求一次列表后，再进入详情页，就不再需要重新请求，对网络的依赖也是最小的。同理，对于一些阅读类APP，前几页的文章，用户查看详情的概率较高，可以在返回文章列表的时候携带正文内容，则可以实现秒开详情，也可以判断网络状态，wifi场景下可以将详情数据都返回。            {         "md5"... // 校验所有item的detail，只有在新订单，或订单完成后移除的情况下，md5才会变化         "orderList":[{             "id"...             "status"...             "detail":{ // detail中尽量只保留变化情况较少的字段，避免md5频繁变化，如status就移出到item中存放                 "type"...                 "desc"...             }         },{             "id"...             "status"...             "detail":{                 "type"...                 "desc"...             }         }]    }        总结  暂时先这么多吧，水平有限，权当是抛砖引玉，如果有更好的设计，请在文章下方留言告诉我，交流想法，互相学习。谢谢支持～分享一份基于本文编写的接口文档模板，仅供参考接口模板。]]></content>
      <categories>
        
          <category> android </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[高仿蘑菇街欢迎页]]></title>
      <url>/android/2018/07/10/%E9%AB%98%E4%BB%BF%E8%98%91%E8%8F%87%E8%A1%97%E6%AC%A2%E8%BF%8E%E9%A1%B5/</url>
      <content type="text"><![CDATA[####蘑菇街欢迎页####高仿效果这里这里…Demo下载地址#####效果拆解  首先可以把整体效果拆分为静态，动态2部分。  静态：1个支持4个页面的ViewPager，每个页面的展示相对固定，不会根据offset进行改变。          第1-4页的顶部文案      第4页的开始按钮        动态：摆放在viewPager上会变形的自定义View，根据offset动态调整需要绘制的元素的宽高，left，top，透明度等。          第1页-&gt;第2页                  0%-&gt;50%，矩形背景高度增加，先上移，再下移          0%-&gt;50%，模特图，文案，下移，渐变消失          50%-100%，左右裂变出2张背景图，并左右移开          50%-&gt;100%，第2页，顶部，底部图，渐变显示          50%-&gt;100%，第2页，3张模特图逐步放大显示          0%-&gt;100%，底部背景图跟随向左偏移，并消失                    第2页-&gt;第3页                  0%-&gt;50%，矩形背景宽度减少，上移          0%-&gt;50%，顶部，底部图，3张模特图渐变消失          0%-&gt;50%，2张裂变背景图跟随向左偏移，并消失          50%-&gt;100%，第3页，6张模特图逐步放大，渐变显示                    第3页-&gt;第4页                  0%-&gt;50%，矩形背景宽度，高度减少，并逆时针进行旋转          0%-&gt;50%，6张模特图缩小，渐变消失          50%-&gt;100%，左右裂变出2张背景图，并左右移开          50%-&gt;100%，顶部模特，文案，渐变显示          50%-&gt;100%，底部3长模特图逐步放大，渐变显示                      以上是对部分实现细节的分析，抽取；本文demo会全部实现以上变化效果。#####实现步骤  1.实现静态的ViewPager2.根据offset实现矩形背景变化3.根据offset实现第1页底部背景，第2，4页裂变背景图变化4.根据offset实现页面切换时，每个页面图片元素的隐藏，显示，变形等效果  实现静态的ViewPager自定义ViewPager，每个页面是一个独立layout，可以自由实现每个页面的顶部文案，和第4个页面的Buttonpublic class MoguViewPager extends RelativeLayout {    private MoguViewPagerAdapter mAdapter;    private ViewPager mViewPager;    private List&lt;View&gt; mViewList = new ArrayList&lt;&gt;();    /** 每个页面都是一个layout */    private int[] mLayouts = new int[] {R.layout.guide_view_one, R.layout.guide_view_two, R.layout.guide_view_three,        R.layout.guide_view_four};    public MoguViewPager(Context context) {        super(context);        init();    }    public MoguViewPager(Context context, AttributeSet attrs) {        super(context, attrs);        init();    }    private void init() {        inflate(getContext(), R.layout.layout_mogu_viewpager, this);        mViewPager = (ViewPager) this.findViewById(R.id.viewpager);        {            /** 初始化4个页面 */            for (int i = 0; i &lt; mLayouts.length; i++) {                View view = View.inflate(getContext(), mLayouts[i], null);                mViewList.add(view);            }        }        mAdapter = new MoguViewPagerAdapter(mViewList, getContext());        mViewPager.setAdapter(mAdapter);    }}&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"                android:layout_width="match_parent"                android:layout_height="match_parent"&gt;    &lt;android.support.v4.view.ViewPager        android:id="@+id/viewpager"        android:layout_width="match_parent"        android:layout_height="match_parent"        android:layout_centerHorizontal="true"        android:clipChildren="false"/&gt;    &lt;!--这里准备放个自定义View--&gt;&lt;/RelativeLayout&gt;第一步完成，实现代码还是比较简单的，直接看效果：  根据offset实现矩形背景变化自定义会变形的TransforView，在xml布局中摆放在ViewPager之上&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"                android:layout_width="match_parent"                android:layout_height="match_parent"&gt;    &lt;android.support.v4.view.ViewPager        android:id="@+id/viewpager"        android:layout_width="match_parent"        android:layout_height="match_parent"        android:layout_centerHorizontal="true"        android:clipChildren="false"/&gt;    &lt;com.listen.test_mogu_viewpager.viewpager.TransforView        android:id="@+id/transfor_view" android:layout_width="match_parent"        android:layout_height="450dp"        android:layout_centerInParent="true"/&gt;&lt;/RelativeLayout&gt;给ViewPager添加addOnPageChangeListener()监听，在onPageScrolled()的时候将position，positionOffset，positionOffsetPixels传递给TransforView。mViewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {            @Override            public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {                mTransforView.transfor(position, positionOffset, positionOffsetPixels);            }        });在TransforView中，首先定义页面切换时变化的参数，比如第1页-&gt;第2页切换时，第1页的矩形背景高度放大40%，上移30dp，下移60dp，则只需要定义FIRST_HEIGHT=0.4，FIRST_TOP1=-30dp，FIRST_TOP2 =60dp三个参数即可。/** * 第1页-&gt;第2页 * 0%-&gt;50%，矩形背景高度增加40%，先上移30dp，再下移60dp */public static final float FIRST_HEIGHT = 0.4f;// 第1个页面高度缩放比例，正：放大，负：缩小public final int FIRST_TOP1 = -dp2px(30);// 第1个页面top移动距离，正：下移，负：上移public final int FIRST_TOP2 = dp2px(60);// 第1个页面top移动距离，正：下移，负：上移public static final float FIRST_RATE = 0.5f;// 在偏移50%处，进行下一页的显示/** * 第2页-&gt;第3页 * 0%-&gt;50%，矩形背景宽度减少15%，上移20dp */public static final float SECOND_WIDTH = -0.15f;// 第2个页面宽度缩放比例，正：放大，负：缩小public final int SECOND_TOP = -dp2px(20);// 第2个页面top移动距离比例，正：下移，负：上移public static final float SECOND_RATE = 0.5f;// 在偏移50%处，进行下一页的显示/** * 第3页-&gt;第4页 * 0%-&gt;50%，矩形背景宽度，高度减少10%，并逆时针进行旋转10度 */public static final float THIRD_WIDTH = -0.1f;// 第3个页面宽度缩放比例，正：放大，负：缩小public static final float THIRD_HEIGHT = -0.1f;// 第3个页面高度缩放比例，正：放大，负：缩小public static final int THIRD_DEGREE = -10;// 第3个页面角度调整，正：顺时针，负：逆时针public static final float THIRD_RATE = 0.5f;// 在偏移50%处，进行下一页的显示/** * 第1页初始化矩形背景的宽，高，left，top */private float mPage1RectBgDefaultWidth = dp2px(260);private float mPage1RectBgDefaultHeight = dp2px(230);private float mPage1RectBgDefaultLeft = getScreenWidth() / 2 - mPage1RectBgDefaultWidth / 2;//left=屏幕宽度/2-矩形宽度/2private float mPage1RectBgDefaultTop = dp2px(80);/** * 第1页-&gt;第2页 * 在第1页的基础上进行变化 * 1.height放大 * 2.top先上移n，在下移n*2 */private float mPage2RectBgDefaultWidth = mPage1RectBgDefaultWidth;private float mPage2RectBgDefaultHeight = mPage1RectBgDefaultHeight * (1 + FIRST_HEIGHT);// 第2页的高度=第一页高度*1.4private float mPage2RectBgDefaultLeft = mPage1RectBgDefaultLeft;private float mPage2RectBgDefaultTop = mPage1RectBgDefaultTop + FIRST_TOP1 + FIRST_TOP2;//第2页的top=第一页的top-30dp+60dp/** * 第2页-&gt;第3页 * 在第2页的基础上进行变化 * 1.宽度缩小 * 2.top上移 */private float mPage3RectBgDefaultWidth = mPage2RectBgDefaultWidth * (1 + SECOND_WIDTH);private float mPage3RectBgDefaultHeight = mPage2RectBgDefaultHeight;private float mPage3RectBgDefaultLeft = getScreenWidth() / 2 - mPage3RectBgDefaultWidth / 2;//第3页的left=屏幕的宽度/2-矩形背景宽度/2private float mPage3RectBgDefaultTop = mPage2RectBgDefaultTop + SECOND_TOP;/** * 第3页-&gt;第4页 * 在第3页的基础上进行变化 * 1.宽度缩小 * 2.高度缩小 * 2.逆时针旋转 */private float mPage4RectBgDefaultWidth = mPage3RectBgDefaultWidth * (1 + THIRD_WIDTH);private float mPage4RectBgDefaultHeight = mPage3RectBgDefaultHeight * (1 + THIRD_HEIGHT);private float mPage4RectBgDefaultLeft = getScreenWidth() / 2 - mPage4RectBgDefaultWidth / 2;private float mPage4RectBgDefaultTop = mPage3RectBgDefaultTop;private float mPage4ModelDefaultWidth = (mPage4RectBgDefaultWidth - padding() * 4) / 3;TransforView的transfor()方法负责接收position，positionOffset，positionOffsetPixels，并根据position判断当前第几页，从而决定要实现哪些效果。比如在第1页-&gt;第2页的0%-50区间时，需要将高度放大40%：mRectBgCurrentHeight =(int) (mPage1RectBgDefaultHeight * (1 + FIRST_HEIGHT * positionOffset * (1 / FIRST_RATE)))。mRectBgCurrentHeight是矩形背景当前的高度，是个动态值，mPage1RectBgDefaultHeight是屏幕处于第1页时矩形背景的初始值，只要基于这个初始值，根据positionOffset计算偏移的比例，就可以知道当前动态的高度值应该是多少。public void transfor(int position, float positionOffset, int positionOffsetPixels) {    mCurrentPageIndex = position;    if (fromPage1ToPage2(position)) {        if (positionOffset &lt; FIRST_RATE) {            /** 第1页，在0-&gt;50%区间偏移 */            /** 矩形背景，高度放大40% */            /**             * 偏移到50%的时候height需要放大40%，defaultHeight=400，targetHeight=400*1.4=560             *             * offset=0             * 400 * (1 + 0.4 * 0 * (1 / 0.5)) = 400             *             * offset=0.25             * 400 * (1 + 0.4 * 0.25 * (1 / 0.5)) = 400 * 1.2 = 480             *             * offset=0.5             * 400 * (1 + 0.4 * 0.5 * (1 / 0.5)) = 400 * 1.4 = 560             *             */            mRectBgCurrentHeight =                    (int) (mPage1RectBgDefaultHeight * (1 + FIRST_HEIGHT * positionOffset * (1 / FIRST_RATE)));            /** 矩形背景，向上移动30dp */            mRectBgCurrentTop = (int) (mPage1RectBgDefaultTop + (FIRST_TOP1 * positionOffset * (1 / FIRST_RATE)));        } else {            /** 第1页，在50%-&gt;100%区间偏移 */            /** 矩形背景，上移30dp后，向下偏移60dp */            mRectBgCurrentTop =                    (int) (mPage1RectBgDefaultTop + FIRST_TOP1 + (FIRST_TOP2 * (positionOffset - FIRST_RATE) * 1.0 / (1 - FIRST_RATE)));        }    } else if (fromPage2ToPage3(position)) {        /** 矩形背景，宽度缩小15% */        mRectBgCurrentWidth = (int) (mPage2RectBgDefaultWidth * (1 + SECOND_WIDTH * positionOffset));        mRectBgCurrentLeft = getScreenWidth() / 2 - mRectBgCurrentWidth / 2;        /** 矩形背景，上移20dp */        mRectBgCurrentTop = (int) (mPage2RectBgDefaultTop + (SECOND_TOP * positionOffset));    } else if (fromPage3ToPage4(position)) {        /** 背景矩形的宽度，减少10% */        mRectBgCurrentWidth = mPage3RectBgDefaultWidth * (1 + THIRD_WIDTH * positionOffset);        mRectBgCurrentLeft = getScreenWidth() / 2 - mRectBgCurrentWidth / 2;        /** 背景矩形的高度，减少10% */        mRectBgCurrentHeight = mPage3RectBgDefaultHeight * (1 + THIRD_HEIGHT * positionOffset);        /** 逆时针旋转10度 */        mRectBgCurrentDegree = THIRD_DEGREE * positionOffset;    }     /** 请求重新绘制 */    postInvalidate();}最后在onDraw方法中，调用canvas.drawRoundRect()将计算好宽，高，left，top的圆角矩形在绘制在canvas上即可。protected void onDraw(Canvas canvas) {    super.onDraw(canvas);    RectF rect = new RectF();    rect.left = mRectBgCurrentLeft;    rect.top = mRectBgCurrentTop;    rect.right = rect.left + mRectBgCurrentWidth;    rect.bottom = rect.top + mRectBgCurrentHeight;    canvas.rotate(mRectBgCurrentDegree, rect.left + mRectBgCurrentWidth / 2, rect.top + mRectBgCurrentHeight / 2);    canvas.drawRoundRect(rect, mRectBgDefaultCorner, mRectBgDefaultCorner, mRectBgPaint);}第2步：通过ViewPager的偏移offset，实现了矩形背景在页面间切换时的变化效果，如下：  根据offset实现第1页底部背景，第2，4页裂变图背景图变化在TransforView的init()初始化方法中，获取并设置图片的默认宽，高，left，top。这里封装了1个ViewModel，里面记录了在canvas上绘制图形需要的bitmap，paint，matrix，width，height，left，top等属性。在调用ViewModel.create()的时候，通过matrix.postScale()将Bitmap缩放一定比例，以便在矩形背景上进行精确的绘制，比如：矩形背景的200，要在1排展示3张图，则每张图的宽度=(200-矩形左边距-矩形右边距-中间2张图的左右边距)/3。public ViewModel create() {    /** 缩放图片尺寸到合适的比例 */    matrix.postScale(currentWidth / bitmap.getWidth(), currentHeight / bitmap.getHeight());    bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);    return this;}private void init() {    /** 第1页，底部背景图 */    mPage1BottomBg =        new ViewModel(getContext(), R.drawable.one_bottom_bg).alpha(255)            .width(mPage1RectBgDefaultWidth - padding() * 2)            .left(mPage1RectBgDefaultLeft + padding())            // top距离=矩形背景top+height+5dp边距            .top(mPage1RectBgDefaultTop + mPage1RectBgDefaultHeight + padding())            .create();    /** 第2页，裂变背景图 */    for (int i = 0; i &lt; 2; i++) {        mPage2Split[i] =            new ViewModel(getContext(), R.drawable.two_bg).width(mPage2RectBgDefaultWidth)                .height(mPage2RectBgDefaultHeight)                .left(mPage2RectBgDefaultLeft)                .top(mPage2RectBgDefaultTop)                .create();    }    /** 第4页，2张裂变背景图 */    for (int i = 0; i &lt; mPage4Split.length; i++) {        mPage4Split[i] =            new ViewModel(getContext(), R.drawable.four_bg)                    .width(mPage4RectBgDefaultWidth)                .height(mPage4RectBgDefaultHeight)                .left(mPage4RectBgDefaultLeft)                .top(mPage4RectBgDefaultTop);    }}在transfor()中修改图片left，top，实现移动；第1页的底部背景图，根据viewPager向左滑动的距离，跟随左移，直到消失不可见。在第1页滑动到50%时，显示第2页裂变背景图，根据offset分别左右平移，第4页裂变图原理一致，只是绘制前需要通过Matrix.postRotate()将图进行旋转。private void transfor(int position, float positionOffset, int positionOffsetPixels) {        if (fromPage1ToPage2(position)) {            /** 第1页，底部背景图，根据页面pian yi偏移offset向左偏移 */            mPage1BottomBg.currentLeft = mPage1BottomBg.defaultLeft - positionOffsetPixels;            if (positionOffset &lt; FIRST_RATE) {            } else {                /** 第2页，计算裂变背景图的偏移px，并修改透明度渐变显示 */                float offset = (mPage1RectBgDefaultWidth + dp2px(15)) * ((positionOffset - FIRST_RATE) * (1 / (1 - FIRST_RATE)));                mPage2Split[0].currentLeft = mPage2Split[0].defaultLeft - offset;                mPage2Split[1].currentLeft = mPage2Split[0].defaultLeft + offset;                /**                 * 偏移到50%的时候alpha需要为0，偏移到100%，alpha需要为255，不过此时positionOffset的取值=0.5~1                 *                 * offset=0.5                 * 255 * (0.5 - 0.5) * (1 / (1 - 0.5)))=255 * 0 = 0                 *                 * offset=0.75                 * 255 * (0.75 - 0.5) * (1 / (1 - 0.5)))=255 * 0.5 = 127.5                 *                 * offset=1                 * 255 * (1 - 0.5) * (1 / (1 - 0.5)))=255 * 1 = 255                 */                mPage2Split[0].alpha((int) (255 * (positionOffset - FIRST_RATE) * (1 / (1 - FIRST_RATE))));                mPage2Split[1].alpha((int) (255 * (positionOffset - FIRST_RATE) * (1 / (1 - FIRST_RATE))));            }        } else if (fromPage2ToPage3(position)) {            if (positionOffset &lt; SECOND_RATE) {                        }        } else if (fromPage3ToPage4(position)) {            if (positionOffset &lt; THIRD_RATE) {            } else {                /** 显示第4页，裂变背景图，并向左右平移 */                float offset = (mPage4RectBgDefaultWidth + dp2px(40)) * ((positionOffset - THIRD_RATE) * (1 / (1 - THIRD_RATE)));                for (int i = 0; i &lt; mPage4Split.length; i++) {                    mPage4Split[i].matrix.reset();                    mPage4Split[i].matrix.postScale(mPage4RectBgDefaultWidth / mPage4Split[i].bitmap.getWidth(), mPage4RectBgDefaultHeight / mPage4Split[i].bitmap.getHeight());                    float currentLeft = 0;                    if (i == 0) {                        // 左移                        currentLeft = mPage4RectBgDefaultLeft - offset;                    } else if (i == 1) {                        // 右移                        currentLeft = mPage4RectBgDefaultLeft + offset;                    }                    // 平移                    mPage4Split[i].matrix.postTranslate(currentLeft, mPage4RectBgDefaultTop);                    // 旋转角度                    mPage4Split[i].matrix.postRotate(THIRD_DEGREE, currentLeft + mPage4RectBgDefaultWidth/2,                            mPage4RectBgDefaultTop + mPage4RectBgDefaultHeight/2);                    mPage4Split[i].alpha((int) (255 * ((positionOffset - THIRD_RATE) * (1 / (1 - THIRD_RATE)))));                }            }        }    }效果如下：  4个页面切换时，实现每个页面图片元素的隐藏，显示，变形等效果在transfor()中，根据position判断当前页数，才知道当前是从第几页滑动到第几页，该隐藏，或显示哪些view。private void transfor(int position, float positionOffset, int positionOffsetPixels) {    if (fromPage1ToPage2(position)) {        /** 第1页，底部背景图，根据页面向左偏移 */        mPage1BottomBg.currentLeft = mPage1BottomBg.defaultLeft - positionOffsetPixels;        if (positionOffset &lt; FIRST_RATE) {                    /** 第1页，在0-&gt;50%区间偏移 */            /** 矩形背景，高度放大40%，向上移动30dp */            transformRectBgFrom1To2Before(positionOffset);            /** 第1页，渐渐隐顶部图，底部图；透明度渐变消失，偏移到50%时完全消失 */            stepByHidePage1Views(positionOffset);        } else {            /** 第1页，在50%-&gt;100%区间偏移 */            /** 矩形背景，上移30dp后，向下偏移60dp */            transformRectBgFrom1To2After(positionOffset);            /** 第2页，渐渐显示顶部，3张模特图，底部图 */            stepByShowPage2Views(positionOffset);        }    } else if (fromPage2ToPage3(position)) {            /** 矩形背景，宽度缩小15%，上移20dp */           transformRectBgFrom2To3(positionOffset);               if (positionOffset &lt; SECOND_RATE) {               /** 第2页，在0-&gt;50%区间偏移，渐渐隐藏顶部，中间，底部，裂变背景图 */               stepByHidePage2Views(positionOffset, positionOffsetPixels);           } else {               /** 第2页，在50-&gt;100%区间偏移，渐渐显示第3页，6张模特图 */               stepByShowPage3Views(positionOffset);           }    } else if (fromPage3ToPage4(position)) {            /** 背景矩形的宽度，高度减少10%，逆时针旋转10度 */            transformRectBgFrom3To4(positionOffset);            if (positionOffset &lt; THIRD_RATE) {                /** 渐渐缩放，隐藏第3页，6张模特图 */                stepByHidePage3Views(positionOffset);            } else {                /** 渐渐显示第4页，顶部图，底部3张模特图，分裂背景图 */                stepByShowPage4Views(positionOffset);            }    }}第1页-&gt;第2页，偏移区间0%-50%时  矩形背景，高度放大40%，向上移动30dp  渐渐隐藏第1页顶部，底部图；透明度渐变消失，偏移到50%时完全消失private void transformRectBgFrom1To2Before(float positionOffset) {        /** 矩形背景，高度放大40% */        /**         * 偏移到50%的时候height需要放大40%，defaultHeight=400，targetHeight=400*1.4=560         *         * offset=0         * 400 * (1 + 0.4 * 0 * (1 / 0.5)) = 400         *         * offset=0.25         * 400 * (1 + 0.4 * 0.25 * (1 / 0.5)) = 400 * 1.2 = 480         *         * offset=0.5         * 400 * (1 + 0.4 * 0.5 * (1 / 0.5)) = 400 * 1.4 = 560         *         */        mRectBgCurrentHeight =            (int) (mPage1RectBgDefaultHeight * (1 + FIRST_HEIGHT * positionOffset * (1 / FIRST_RATE)));        /** 矩形背景，向上移动30dp */        mRectBgCurrentTop = (int) (mPage1RectBgDefaultTop + (FIRST_TOP1 * positionOffset * (1 / FIRST_RATE)));private void stepByHidePage1Views(float positionOffset) {        /**         * 偏移到50%的时候alpha需要为0，view不可见         *         * offset=0         * 255-(255*0.0*(1/0.5)) = 0         *         * offset=0.25         * 255-(255*0.25*(1/0.5)) = 127         *         * offset=0.5         * 255-(255*0.5*(1/0.5)) = 255         */        mPage1Top.alpha((int) (255 - (255 * positionOffset * (1 / FIRST_RATE))));        mPage1Bottom.alpha((int) (255 - (255 * positionOffset * (1 / FIRST_RATE))));        /** 第1页，顶部图向下移动 */        mPage1Top.currentTop = mPage1Top.defaultTop + (FIRST_TOP2 + FIRST_TOP1) * positionOffset * (1 / FIRST_RATE);        /** 第1页，底部图跟随顶部图向下移动 */        mPage1Bottom.currentTop = mPage1Top.currentTop + mPage1Top.defaultHeight + padding();    }第1页-&gt;第2页，偏移区间50%-100%时  矩形背景，向下移动60dp  显示第2页裂变背景图，并左右平移  逐渐显示第2页，顶部，底部图，3张模特图private void transformRectBgFrom1To2After(float positionOffset) {        /** 快速滑动的时候，可能丢失最后一次绘制，所以需要在这里调重新设置一次，保证变化完成 */        mRectBgCurrentHeight = mPage2RectBgDefaultHeight;        mRectBgCurrentTop = mPage1RectBgDefaultTop + FIRST_TOP1;        /** 第1页，在50%-&gt;100%区间偏移 */        /** 矩形背景，在上上偏移30dp后，向下偏移60dp */        mRectBgCurrentTop =            (int) (mPage1RectBgDefaultTop + FIRST_TOP1 + (FIRST_TOP2 * (positionOffset - FIRST_RATE) * 1.0 / (1 - FIRST_RATE)));    }private void stepByShowPage2Views(float positionOffset) {        /** 第2页，顶部图，跟随矩形背景下移 */        mPage2Top.currentTop = mRectBgCurrentTop + padding();        /** 第2页，底部图，跟随矩形背景下移 */        mPage2Bottom.currentTop = mPage2Center[0].currentTop + mPage2Center[0].defaultHeight + padding();        /** 第2页，计算裂变背景图的偏移px，并修改透明度渐变显示 */        float offset =            (mPage1RectBgDefaultWidth + dp2px(15)) * ((positionOffset - FIRST_RATE) * (1 / (1 - FIRST_RATE)));        mPage2Split[0].currentLeft = mPage2Split[0].defaultLeft - offset;        mPage2Split[1].currentLeft = mPage2Split[0].defaultLeft + offset;        /**         * 偏移到50%的时候alpha需要为0，偏移到100%，alpha需要为255，不过此时positionOffset的取值=0.5~1         *         * offset=0.5         * 255 * (0.5 - 0.5) * (1 / (1 - 0.5)))=255 * 0 = 0         *         * offset=0.75         * 255 * (0.75 - 0.5) * (1 / (1 - 0.5)))=255 * 0.5 = 127.5         *         * offset=1         * 255 * (1 - 0.5) * (1 / (1 - 0.5)))=255 * 1 = 255         */        mPage2Split[0].alpha((int) (255 * (positionOffset - FIRST_RATE) * (1 / (1 - FIRST_RATE))));        mPage2Split[1].alpha((int) (255 * (positionOffset - FIRST_RATE) * (1 / (1 - FIRST_RATE))));        /** 第2页，顶部，底部图，透明度渐变显示，偏移量达到100%，完成显示 */        mPage2Top.alpha((int) (255 * (positionOffset - FIRST_RATE) * (1 / (1 - FIRST_RATE))));        mPage2Bottom.alpha((int) (255 * (positionOffset - FIRST_RATE) * (1 / (1 - FIRST_RATE))));        /** 第2页，显示中间3张模特图 */        for (int i = 0; i &lt; mPage2Center.length; i++) {            if (i == 0) {                /** 第2页，显示第1张模特图 */                mPage2Center[i].currentWidth =                    mPage2Center[i].defaultWidth * (positionOffset - FIRST_RATE) * 1 / (1 - FIRST_RATE);                mPage2Center[i].currentHeight =                    mPage2Center[i].defaultHeight * (positionOffset - FIRST_RATE) * 1 / (1 - FIRST_RATE);                mPage2Center[i].alpha((int) (255 * (positionOffset - FIRST_RATE) * (1 / (1 - FIRST_RATE))));                mPage2Center[i].currentTop = mPage2Top.currentTop + mPage2Top.currentHeight + padding();            } else {                /** 第2，3张模特图，在前1张显示到一半时才显示 */                if (mPage2Center[i - 1].currentWidth &gt;= mPage2Center[i - 1].defaultWidth / 2) {                    float rate = mPage2Center[i - 1].widthRate() - 0.5f;                    mPage2Center[i].currentWidth = mPage2Center[i].defaultWidth * (rate * 2);                    mPage2Center[i].currentHeight = mPage2Center[i].defaultHeight * (rate * 2);                    /** 第2，3张模特图，需要根据第1张图计算left */                    mPage2Center[i].currentLeft =                        mPage2Center[0].currentLeft + mPage2Center[0].currentWidth + padding();                    mPage2Center[i].currentTop = mPage2Top.currentTop + mPage2Top.currentHeight + padding();                    if (i == 2) {                        /** 第3张模特图，根据第2张图计算top */                        mPage2Center[i].currentTop =                            mPage2Center[1].currentTop + mPage2Center[1].currentHeight + padding();                    }                    mPage2Center[i].alpha((int) (255 * (positionOffset * rate * 2)));                } else {                    mPage2Center[i].alpha(0);                }            }        }    }第2页-&gt;第3页，偏移区间0%-100%时  矩形背景，宽度缩小15%  矩形背景，上移20dpprivate void transformRectBgFrom2To3(float positionOffset) {        /** 快速滑动的时候，可能丢失最后一次绘制，所以需要在这里调重新设置一次，保证变化完成 */        mRectBgCurrentHeight = mPage2RectBgDefaultHeight;        mRectBgCurrentTop = mPage2RectBgDefaultTop;        /** 矩形背景，宽度缩小15% */        mRectBgCurrentWidth = (int) (mPage2RectBgDefaultWidth * (1 + SECOND_WIDTH * positionOffset));        mRectBgCurrentLeft = getScreenWidth() / 2 - mRectBgCurrentWidth / 2;        /** 矩形背景，上移20dp */        mRectBgCurrentTop = (int) (mPage2RectBgDefaultTop + (SECOND_TOP * positionOffset));    }第2页-&gt;第3页，偏移区间0%-50%时  裂变背景图跟随滑动，向左偏移至消失  渐渐减少透明度，隐藏第2页的顶部图，3张模特图，底部图private void stepByHidePage2Views(float positionOffset, int positionOffsetPixels) {        /** 裂变背景图，跟随滑动，向左偏移至消失 */        mPage2Split[0].currentLeft =            (mPage2Split[0].defaultLeft - mPage1RectBgDefaultWidth - dp2px(15)) - positionOffsetPixels                * (1 / SECOND_RATE);        mPage2Split[1].currentLeft =            (mPage2Split[1].defaultLeft + mPage1RectBgDefaultWidth + dp2px(15)) - positionOffsetPixels                * (1 / SECOND_RATE);        mPage2Split[0].alpha((int) (255 - (255 * positionOffset * (1 / SECOND_RATE))));        mPage2Split[1].alpha((int) (255 - (255 * positionOffset * (1 / SECOND_RATE))));        /** 顶部图，3张模特图，底部图，跟随矩形背景上移 */        mPage2Top.currentTop = mRectBgCurrentTop + padding();        mPage2Center[0].currentTop = mPage2Top.currentTop + mPage2Top.currentHeight + padding();        mPage2Center[1].currentTop = mPage2Center[0].currentTop;        mPage2Center[2].currentTop = mPage2Center[1].currentTop + mPage2Center[1].currentHeight;        mPage2Bottom.currentTop = mPage2Center[0].currentTop + mPage2Center[0].currentHeight + padding();        /** 渐渐减少透明度，隐藏第2页的顶部图，3张模特图，底部图 */        mPage2Top.alpha((int) (255 - (255 * positionOffset * (1 / SECOND_RATE))));        mPage2Bottom.alpha((int) (255 - (255 * positionOffset * (1 / SECOND_RATE))));        for (ViewModel viewModel : mPage2Center) {            viewModel.alpha((int) (255 - (255 * positionOffset * (1 / SECOND_RATE))));        }        /** 因为矩形背景变窄了，所以渐渐减少第2页顶部图，底部图的宽度，实现跟随矩形背景宽度变化 */        mPage2Top.currentWidth = mRectBgCurrentWidth - padding() * 2;        mPage2Top.currentLeft = mRectBgCurrentLeft + padding();        mPage2Bottom.currentWidth = mRectBgCurrentWidth - padding() * 2;        mPage2Bottom.currentLeft = mRectBgCurrentLeft + padding();        mPage2Bottom.currentLeft = mRectBgCurrentLeft + padding();        /** 因为矩形背景变窄了，所以渐渐减少第2，3张模特图的宽高，left和top，实现跟随矩形背景宽度变化 */        mPage2Center[0].currentLeft = mRectBgCurrentLeft + padding();        mPage2Center[1].currentWidth = mRectBgCurrentWidth - padding() * 3 - mPage2Center[0].defaultWidth;        mPage2Center[1].currentHeight = mPage2Center[1].currentWidth;        mPage2Center[1].currentLeft = mPage2Center[0].currentLeft + mPage2Center[0].defaultWidth + padding();        mPage2Center[2].currentWidth = mRectBgCurrentWidth - padding() * 3 - mPage2Center[0].defaultWidth;        mPage2Center[2].currentHeight = mPage2Center[2].currentWidth;        mPage2Center[2].currentLeft = mPage2Center[0].currentLeft + mPage2Center[0].defaultWidth + padding();        mPage2Center[2].currentTop = mPage2Center[1].currentTop + mPage2Center[1].currentHeight + padding();    }第2页-&gt;第3页，偏移区间50%-100%时  依次显示第3页，6张模特图private void stepByShowPage3Views(float positionOffset) {        /** 第2页，在50-&gt;100%区间偏移，显示第3页，6张模特图 */        for (int i = 0; i &lt; mPage3Model.length; i++) {            if (i == 0) {                /** 第1张模特图先显示 */                if (mPage3Model[i].paint.getAlpha() &lt; 255) {                    mPage3Model[i].alpha((int) (255 * (positionOffset - SECOND_RATE) * (1 / (1 - SECOND_RATE))));                }            } else {                /** 其他模特图在前1张显示50%透明度的时候再依次展示 */                if (mPage3Model[i - 1].paint.getAlpha() &gt;= 255 / 2) {                    float rate = mPage3Model[i - 1].paint.getAlpha() / 255.0f - 0.5f;                    mPage3Model[i].alpha((int) (255 * (rate * 2)));                } else {                    mPage3Model[i].alpha(0);                }            }            /** 6张模特图，跟随矩形背景上移 */            if (i &lt; mPage3ModelResources.length / 2) {                /** 第1排，3张模特图的top计算 */                mPage3Model[i].currentTop = mRectBgCurrentTop + padding();            } else {                /** 第1排，3张模特图的top，需要加上第一排的height */                mPage3Model[i].currentTop = mRectBgCurrentTop + mPage3ModelDefaultHeight + padding() * 2;            }        }    }第3页-&gt;第4页，偏移区间0%-100%时  矩形背景，宽度缩小10%  矩形背景，高度缩小10%  矩形背景，逆时针旋转10度private void transformRectBgFrom3To4(float positionOffset) {        /** 快速滑动的时候，可能丢失最后一次绘制，所以需要在这里调重新设置一次，保证变化完成 */        mRectBgCurrentWidth = mPage3RectBgDefaultWidth;        mRectBgCurrentTop = mPage3RectBgDefaultTop;        /** 调整第4页，背景矩形的宽高和角度 */        /** 背景矩形的宽度，在第3页调整宽度的基础上进行缩小 */        mRectBgCurrentWidth = mPage3RectBgDefaultWidth * (1 + THIRD_WIDTH * positionOffset);        mRectBgCurrentLeft = getScreenWidth() / 2 - mRectBgCurrentWidth / 2;        /** 背景矩形的高度，在第2页调整高度的基础上进行缩小 */        mRectBgCurrentHeight = mPage3RectBgDefaultHeight * (1 + THIRD_HEIGHT * positionOffset);        /** 背景矩形逆时针旋转 */        mRectBgCurrentDegree = THIRD_DEGREE * positionOffset;    }第3页-&gt;第4页，偏移区间0%-50%时  渐渐缩放，隐藏6张模特图private void stepByHidePage3Views(float positionOffset) {        /** 隐藏第3页6张模特图 */        /** 从第1排，第3-1张开始，依次缩放 */        for (int i = mPage3ModelResources.length / 2 - 1; i &gt;= 0; i--) {            if (i == mPage3ModelResources.length / 2 - 1) {                /** 如果是第1排，第3张，则开始缩放 */                mPage3Model[i].currentHeight =                    mPage3Model[i].defaultHeight * (1 - positionOffset * (1 / (1 - THIRD_RATE)));                mPage3Model[i].currentWidth =                    mPage3Model[i].defaultWidth * (1 - positionOffset * (1 / (1 - THIRD_RATE)));            } else {                /** 如果是第1排，第1/2张，则判断后1张缩放到一半的时候开始自己的缩放 */                if (mPage3Model[i + 1].currentHeight &lt;= mPage3Model[i + 1].defaultHeight / 2) {                    mPage3Model[i].currentHeight = mPage3Model[i].defaultHeight * mPage3Model[i + 1].heightRate() * 2;                    mPage3Model[i].currentWidth = mPage3Model[i].defaultWidth * mPage3Model[i + 1].heightRate() * 2;                } else {                    mPage3Model[i].currentHeight = mPage3Model[i].defaultHeight;                    mPage3Model[i].currentWidth = mPage3Model[i].defaultWidth;                }            }            /** 跳转left，top，实现居中缩放 */            mPage3Model[i].currentLeft =                mPage3Model[i].defaultLeft + mPage3Model[i].defaultWidth / 2 - mPage3Model[i].currentWidth / 2;            mPage3Model[i].currentTop =                mPage3Model[i].defaultTop + mPage3Model[i].defaultHeight / 2 - mPage3Model[i].currentHeight / 2;        }        /** 从第1排，第4-6张开始，依次缩放 */        for (int i = mPage3ModelResources.length / 2; i &lt; mPage3ModelResources.length; i++) {            if (i == mPage3ModelResources.length / 2) {                /** 如果是第2排，第1张，则开始缩放 */                mPage3Model[i].currentHeight =                    mPage3Model[i].defaultHeight * (1 - positionOffset * (1 / (1 - THIRD_RATE)));                mPage3Model[i].currentWidth =                    mPage3Model[i].defaultWidth * (1 - positionOffset * (1 / (1 - THIRD_RATE)));            } else {                /** 如果是第2排，第5/6张，则判断前1张缩放到一半的时候开始自己的缩放 */                if (mPage3Model[i - 1].currentHeight &lt;= mPage3Model[i - 1].defaultHeight / 2) {                    mPage3Model[i].currentHeight = mPage3Model[i].defaultHeight * mPage3Model[i - 1].heightRate() * 2;                    mPage3Model[i].currentWidth = mPage3Model[i].defaultWidth * mPage3Model[i - 1].heightRate() * 2;                } else {                    mPage3Model[i].currentHeight = mPage3Model[i].defaultHeight;                    mPage3Model[i].currentWidth = mPage3Model[i].defaultWidth;                }            }            /** 跳转left，top，实现居中缩放 */            mPage3Model[i].currentLeft =                mPage3Model[i].defaultLeft + mPage3Model[i].defaultWidth / 2 - mPage3Model[i].currentWidth / 2;            mPage3Model[i].currentTop =                mPage3Model[i].defaultTop + mPage3Model[i].defaultHeight / 2 - mPage3Model[i].currentHeight / 2;        }    }第3页-&gt;第4页，偏移区间50%-100%时  渐渐显示顶部图，底部3张模特图  显示第4页裂变背景图，并左右平移private void stepByShowPage4Views(float positionOffset) {        /** 显示第4页，裂变背景图，并向左右平移 */        float offset = (mPage4RectBgDefaultWidth + dp2px(40)) * ((positionOffset - THIRD_RATE) * (1 / (1 - THIRD_RATE)));        for (int i = 0; i &lt; mPage4Split.length; i++) {            mPage4Split[i].matrix.reset();            mPage4Split[i].matrix.postScale(mPage4RectBgDefaultWidth / mPage4Split[i].bitmap.getWidth(), mPage4RectBgDefaultHeight / mPage4Split[i].bitmap.getHeight());            float currentLeft = 0;            if (i == 0) {                // 左移                currentLeft = mPage4RectBgDefaultLeft - offset;            } else if (i == 1) {                // 右移                currentLeft = mPage4RectBgDefaultLeft + offset;            }            // 平移            mPage4Split[i].matrix.postTranslate(currentLeft, mPage4RectBgDefaultTop);            // 旋转角度            mPage4Split[i].matrix.postRotate(THIRD_DEGREE, currentLeft + mPage4RectBgDefaultWidth/2,                    mPage4RectBgDefaultTop + mPage4RectBgDefaultHeight/2);            mPage4Split[i].alpha((int) (255 * ((positionOffset - THIRD_RATE) * (1 / (1 - THIRD_RATE)))));        }        /** 显示第4页，顶部模特图 */        mPage4Top.alpha((int) (255 * ((positionOffset - THIRD_RATE) * (1 / (1 - THIRD_RATE)))));        /** 显示第4页，底部3张模特图 */        for (int i = 0; i &lt; mPage4Model.length; i++) {            if (i == 0) {                mPage4Model[i].currentWidth =                    mPage4Model[i].defaultWidth * ((positionOffset - THIRD_RATE) * (1 / (1 - THIRD_RATE)));                mPage4Model[i].currentHeight =                    mPage4Model[i].defaultHeight * ((positionOffset - THIRD_RATE) * (1 / (1 - THIRD_RATE)));                mPage4Model[i].alpha((int) (255 * (positionOffset - THIRD_RATE) * (1 / (1 - THIRD_RATE))));            } else {                if (mPage4Model[i - 1].currentWidth &gt;= mPage4ModelDefaultWidth / 2) {                    mPage4Model[i].currentWidth =                        mPage4Model[i].defaultWidth * ((mPage4Model[i - 1].widthRate() - 0.5f) * 2);                    mPage4Model[i].currentHeight =                        mPage4Model[i].defaultHeight * ((mPage4Model[i - 1].widthRate() - 0.5f) * 2);                    mPage4Model[i].currentLeft =                        mPage4Model[i - 1].currentLeft + mPage4Model[i - 1].currentWidth + padding();                    mPage4Model[i].alpha((int) (255 * (mPage4Model[i - 1].widthRate() - 0.5f) * 2));                }            }        }    }最后在onDraw()，将计算好偏移值的view都绘制出来。protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        /** 按重叠顺序绘制 */        if (fromPage1ToPage2(mCurrentPageIndex)) {            /** 绘制第1页，底部背景图 */            drawBitmap(canvas, mPage1BottomBg);            /** 绘制第2页，裂变背景图 */            drawBitmap(canvas, mPage2Split[0]);            drawBitmap(canvas, mPage2Split[1]);            /** 绘制白色矩形背景 */            drawWhiteRectBackgroud(canvas);            drawPage1InCanvas(canvas);            drawPage2InCanvas(canvas);        } else if (fromPage2ToPage3(mCurrentPageIndex)) {            /** 绘制第2页，裂变背景图 */            drawBitmap(canvas, mPage2Split[0]);            drawBitmap(canvas, mPage2Split[1]);            /** 绘制矩形背景 */            drawWhiteRectBackgroud(canvas);            drawPage2InCanvas(canvas);            drawPage3InCanvas(canvas);        } else if (fromPage3ToPage4(mCurrentPageIndex)) {            /** 绘制第4页，裂变背景图 */            drawBitmapMatrix(canvas, mPage4Split[0]);            drawBitmapMatrix(canvas, mPage4Split[1]);            /** 绘制矩形背景 */            drawWhiteRectBackgroud(canvas);            drawPage3InCanvas(canvas);            drawPage4InCanvas(canvas);        } else if (isPage4(mCurrentPageIndex)) {            /** 绘制第4页，裂变背景图 */            drawBitmapMatrix(canvas, mPage4Split[0]);            drawBitmapMatrix(canvas, mPage4Split[1]);            /** 绘制矩形背景 */            drawWhiteRectBackgroud(canvas);            drawPage4InCanvas(canvas);        }    }最终效果：目前还有一些细节的效果，以及适配，性能调优还没实现。虽然原理不难，不过要真正完整的实现以上效果，也算呕心沥血吧！难点就在于如何精细化的控制每个view的属性，因为页面中每个图片的位置，大小都是在参照其他view的基础上进行计算后得出的。现在市场上很多APP的欢迎页都有类似比较动态的效果，原理就是ViewPager+Canvas绘制，掌握了本文的demo，其他实现原理应该是一样样的。感兴趣的朋友可以Github上下载源码查看， 注释还算清晰，有什么问题页欢迎提出，如果本文稍微对您有点启示的话还请点个“喜欢”，谢谢了]]></content>
      <categories>
        
          <category> android </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[性能优化（一）堆内存分析]]></title>
      <url>/android/2018/04/07/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E4%B8%80-%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</url>
      <content type="text"><![CDATA[Memory Monitor的基本使用  新建MainActivity，启动APP    public class MainActivity extends AppCompatActivity {  @Override  protected void onCreate(Bundle savedInstanceState) {      super.onCreate(savedInstanceState);      setContentView(R.layout.activity_main);  }}            在 Android Monitor -&gt; Monitors -&gt; Memory 中，点击”initiate GC”，先手动GC一次，把没用的内存进行回收。    点击”Dump Java Heap”，生成.hprof（hprof文件为特定时间点，Java进程的内存快照）以下是根据.hprof文件生成的内存分析表，本文主要关注Shallow Size和Retained Size，其他column含义可以参考官方-HPROF Viewer and AnalyzerShallow Size和Retained Size  Shallow Size：对象自身占用的内存大小，不包括它引用的对象Retained Size：对象自身占用的内存大小，加上它直接或间接引用的对象大小Dominating Size：管辖的内存大小，大部分情况和Retained一致因为可以通过GC Roots直接访问，所以左图的obj3不是蓝色节点；而右图却是蓝色，因为它已经被包含在 Retained size 中。                   Shallow Size      Retained Size（左）      Retained Size（右）                  obj1      obj1      obj1+obj2+obj4      obj1+obj2+obj3+obj4              obj2      obj2      obj2+obj4      obj2+obj3+obj4      案例分析  如图heap_nothing.png，在MainActivity在新建的时候，初始占用内存1776（以下案例分析基于红米note3机型）。  case 1：空对象TestModel+未初始化。public class TestModel {}public class MainActivity extends AppCompatActivity {    private TestModel mModel;    ...onCreate()}  只定义TestModel成员变量的情况下，内存占用1780=初始内存+引用类型（4）。所以在项目发版前，要把一些没有使用到的变量都清理一遍，积少成多，免得造成内存浪费。  case 2：空对象TestModel+初始化。public class MainActivity extends AppCompatActivity {    private TestModel mModel = new TestModel();    ...onCreate()}  内存占用1788=case1+类信息（8），说明调用new时，即使是空对象，也需要8字节左右的堆空间用于描述该对象的类信息。基于Java是在new的时候才去申请堆空间的特性，在开发中，可以考虑对象的延迟初始化，养成个好习惯，在使用到的时候才去new。  case3：TestModel以局部变量的方式进行定义。public class MainActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        TestModel mModel = new TestModel();    }}  内存占用未变化，还是初始值1776，说明局部变量生命周期只存在于方法内部，方法结束后，即可被gc回收。除非必须，能使用局部变量的情况，就避免定义成员变量。  case4：boolean基础类型。public class MainActivity extends AppCompatActivity {   private boolean mBoolean;    ...onCreate()}  内存占用1777=初始状态+1，说明基础类型boolean的引用类型占用1字节。  case5：Boolean封装类型。public class MainActivity extends AppCompatActivity {   private Boolean mBoolean;    ...onCreate()}  内存占用1780=初始状态+4，装箱类型Boolean本质上也是一个对象，由case1可以推导出引用类型占用4字节。  case6：Boolean封装类型+初始化。public class MainActivity extends AppCompatActivity {   private Boolean mBoolean = new Boolean(true);    ...onCreate()}  内存占用1789=case5+9，如图，Boolean的源码中有个boolean基础类型的字段value，当调用”new Boolean(true)”的时候，根据case2可以推导，类描述信息8字节，根据case4可以推导，value基础类型占用1字节，所以总共增加9字节。同理，可以推导出以下表格：                   boolean/byte      short/char      int/float/String/引用类型/数组引用      long/double/类信息                  内存占用      1      2      4      8        case7：TestModel内部类。public class MainActivity extends AppCompatActivity {    private TestModel mModel = new TestModel();    ...onCreate()    public class TestModel {    }}  占用内存1792=case1（1780）+类信息（8）+this引用（4）。  case8：TestModel静态内部类。public class MainActivity extends AppCompatActivity {    private TestModel mModel = new TestModel();    ...onCreate()    public static class TestModel {    }}  占用内存1788=case1（1780）+类信息（8），静态内部类由于没有外部类的匿名this引用，少占用4字节。  case9：HashMap和SparseArray的对比。public class MainActivity extends AppCompatActivity {    private Map&lt;Integer, Integer&gt; mMap = new HashMap&lt;&gt;();    private SparseArray&lt;Integer&gt; mSparseArray = new SparseArray();    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        for (int i = 0; i &lt; 1000; i++) {            mMap.put(i, i);            mSparseArray.put(i, i);        }    }}  各添加1000条数据，HashMap占用53168，SparseArray占用18653，说明使用SparseArray替代HashMap更节省内存。  case10：OnClickListener三种写法的对比。从节省内存的角度考虑，通过方式3接口回调设置OnClickListener为最优。写法1：匿名类public class MainActivity extends AppCompatActivity {    private Button mButton;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        mButton = (Button) findViewById(R.id.button);        mButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                Toast.makeText(MainActivity.this, "hello", Toast.LENGTH_SHORT).show();            }        });    }}  内存占用=MainActivity（1780）+MainActivity$1（12）=1792。写法2：成员变量类public class MainActivity extends AppCompatActivity {    private Button mButton;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        mButton = (Button) findViewById(R.id.button);        mButton.setOnClickListener(mOnClickListener);    }    private View.OnClickListener mOnClickListener = new View.OnClickListener() {        @Override        public void onClick(View v) {            Toast.makeText(MainActivity.this, "hello", Toast.LENGTH_SHORT).show();        }    };}  内存占用=MainActivity（1784，包含4字节的成员变量）+MainActivity$1（12）=1796。写法3：接口回调public class MainActivity extends AppCompatActivity implements View.OnClickListener {    private Button mButton;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        mButton = (Button) findViewById(R.id.button);        mButton.setOnClickListener(this);    }    @Override    public void onClick(View v) {        Toast.makeText(MainActivity.this, "hello", Toast.LENGTH_SHORT).show();    }}  内存占用=1780（减少1个成员变量，避免通过new创建新的对象，内存占用最少）。  case11：String的初始化。case11_1：public class MainActivity extends AppCompatActivity {   private String mStr = "aaaaa";    ...onCreate()}case11_2：public class MainActivity extends AppCompatActivity {   private String mStr = new String("aaaaa");    ...onCreate()}      “aaaaa”这个String为何占用26字节？按以上方式分析，至少占用内存30=类信息（8）+count（4）+hashCode（4）+char[]引用（4）+char[]数组（10），为何少了4字节？    直接赋值的方式会将”aaaaa”加入到字符串常量池，不占用堆空间；而case11_2的内存占用为 1806=case11_1+26，说明通过new String方式创建的字符串会在堆内存开辟空间。    case12：String的拼接。case12_1：基于case11_1，作字符串”+”拼接。public class MainActivity extends AppCompatActivity {   private String mStr = "aaaaa";   protected void onCreate(Bundle savedInstanceState) {       ...      mStr += "c";   }}  可以发现，拼接后内存占用1808=case11_1（1780）+28，而这28的空间正好是”aaaaac”的内存大小，也就是说在”+”拼接的时候，产生了一个临时的变量用于存储”aaaaac”的结果，并赋值给mStr。印证了《Effective in Java》的第51条中所说”由于字符串不可变，当2个字符串被连接在一起时，他们的内容都要被拷贝”。同时在浅谈StringBuilder这篇文章中也讲到了”+”拼接的时候，会转化为StringBuilder，再通过toString创建一个新的String对象。case12_2：用StringBuilder进行字符串拼接。case12_2_1：初始化1个空的StringBuilderpublic class MainActivity extends AppCompatActivity {  private StringBuilder mStringBuilder = new StringBuilder();    ...onCreate()}  一个空的StringBuilder就占49字节，类信息（8）+count（4）+shared（1）+value引用（4）+value[]数组（32）=49。value这个字符数组占用了32字节，而我们最多也就添加”aaaaac”6个字符，所以这里可以通过new StringBuilder(6)初始化字符数组的大小，避免浪费。case12_2_2：使用StringBuilder进行”aaaaa”+”c”的字符串拼接。public class MainActivity extends AppCompatActivity {    private StringBuilder mStringBuilder = new StringBuilder(6);    @Override    protected void onCreate(Bundle savedInstanceState) {        ...        mStringBuilder.append("aaaaa");        mStringBuilder.append("c");    }}  首先在StringBuilder初始化的时候设置了字符数组大小为6，所以StringBuilder的初始内存占用就变小了，而在完成append(“aaaaa”)，append(“c”)之后，只要当前字符数组的容量够用，就不会继续扩容，避免了String拼接时，内存浪费的问题。当然前提是控制好StringBuilder的char[]初始容量，不然扩容后也会空余一些闲置内存。###总结  1.谨慎创建成员变量：不管有用没用，非基础类型的成员变量只要定义了，至少需要4字节，基础类型成员变量占用大小各不一样。尽量使用局部变量，缩短变量生命周期，促使GC更快回收。2.谨慎new：如case2的TestModel，不管该对象是否为空，至少8字节的类信息占用。如case10的Listener，尽量避免不必要的new。考虑对象的延迟初始化，只有真正使用的时候才new。3.除非必要，否则尽量使用基础类型，避免使用装箱类型。4.少用内部类：内部类如果不需要访问到外部类的成员时，可以抽取成独立外部类，或加static，减少一个this引用（4字节），也可以避免内存泄漏。5.使用google推荐的数据集合类型SparseArray，ArrayMap替代HashMap。6.从节省内存的角度考虑，通过接口回调的方式设置OnClickListener为最优。7.通过StringBuilder替代String进行字符串拼接，最好预先设置好StringBuilder的容量。参考官方-HPROF Viewer and Analyzer]]></content>
      <categories>
        
          <category> android </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[6.0运行时权限的总结与实践]]></title>
      <url>/android/2017/02/05/6.0%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      <content type="text"><![CDATA[####为什么需要6.0运行时权限  更友好  6.0以前的安装时权限，会在应用安装时列出所有需要的权限，当列出一些危险权限时，用户不知每个权限的具体用途，可能因为这些权限警告而放弃安装应用。对于一些非装不可的应用，用户则不得不被迫接受所有权限，很容易安装了一些流氓APP，体验不佳。6.0以后的运行时权限，可以在调用相关功能之前判断权限授权状态，并自定义提示弹框告知用户权限用途，使用户清楚了解之后，再授权使用。  更稳定  6.0系统的手机对于每个应用，都有个权限设置页面，可以手动开关权限，如果用户在设置页面误关了某个权限，若没在程序运行时做判断，则会导致相关功能的调用失败，引起崩溃等。####如何实现运行时权限  设置targetSdkVersion  只有targetSdkVersion&gt;=23，且安装在6.0以上的手机时，运行时权限机制才能正常运作            手机系统      targetSdkVersion&lt;23      targetSdkVersion&gt;=23                  5.0+      安装时权限      安装时权限              6.0+      安装时权限      运行时权限        代码实现  在需要使用某项权限时，通过V4包的checkSelfPermission判断权限是否授权，通过requestPermissions申请某项权限// 需要执行某项需要权限的操作时if (ContextCompat.checkSelfPermission(this, "某项权限") == PackageManager.PERMISSION_GRANTED) {   // 执行操作} else {   // 请求权限   ActivityCompat.requestPermissions(this, new String[]{"某项权限"}, requestCode);}  在Activity的onRequestPermissionsResult回调方法中，处理权限授权结果@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {   if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {       // 授权成功,执行操作   } else {       // 权限被拒绝       if (ActivityCompat.shouldShowRequestPermissionRationale(this, "权限名称")) {           // shouldShowRequestPermissionRationale=true: 表示权限被拒绝,且没有勾选"never ask again"           // 正常的权限被拒绝流程,可以继续申请权限,重复以上流程       } else {           // shouldShowRequestPermissionRationale=false: 在权限被拒绝,且勾选"never ask again"的情况下，返回false           // 继续申请权限的时候,不会再弹出默认的系统弹框,需要自定义提示弹框,并引导用户去权限设置页面,手动开启权限       }   }}####LsPermission工具类的使用  主要实现逻辑参考PermissionGen，封装了权限判断，请求，结果处理等通用逻辑，目前只支持context=AppCompatActivity，如果在Fragment中使用时可以调用getActivity()获取上层AppCompatActivity。private void normal() {   final String[] permissions =       new String[] {Manifest.permission.CALL_PHONE, Manifest.permission.ACCESS_FINE_LOCATION};   PermissionUtil.request(this, permissions, new OnPermissionAdapter() {       /**        * @desc 申请的权限全被授权        */       @Override       public void onGrant() {           showToast("权限被同意");           callPhone();       }       /**        * @desc 权限被拒绝        */       @Override       public void onDeny(List&lt;String&gt; permissions) {           showToast("用户拒绝授权" + permissions.toString());       }       /**        * @desc 权限被拒绝,且勾选"never ask again"        */       @Override       public void onNeverAsk(List&lt;String&gt; permissions) {           showToast("用户拒绝授权, 并勾选 never ask again " + permissions.toString());           PermissionUtil.showNeverAskDialog(MainActivity.this, "这个权限很重要");       }              /**        * @desc 无论权限授权成功还是失败，都会回调        */       @Override       public void always(List&lt;String&gt; grantPermissions, List&lt;String&gt; denyPermissions,           List&lt;String&gt; foreverDenyPermissions) {           showToast("授权: " + grantPermissions.toString() + "\n 拒绝: " + denyPermissions.toString()               + "\n never ask: " + foreverDenyPermissions.toString());       }   });}/*** @desc 将权限回调转发给PermissionUtil处理* @author listen* @date 2017/2/24 13:47*/@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {   PermissionUtil.onRequestPermissionsResult(this, requestCode, permissions, grantResults);   super.onRequestPermissionsResult(requestCode, permissions, grantResults);}  PermissionUtil内部通过SparseArray保存了requestCode和权限回调的键值对，避免了连续点击时重复回调情况，对于不同的权限申请，推荐使用不同的requestCode，避免回调覆盖的问题。private static SparseArray&lt;OnPermissionListener&gt; mPermissionRequestList = new SparseArray&lt;&gt;();public static void request(final Context context, int requestCode, String[] permissions,                          OnPermissionListener listener) {   /** 存在未授权的权限 */   synchronized (mPermissionRequestList) {       if (null != mPermissionRequestList.get(requestCode)) {           /** 当前权限请求已经存在,不重复添加 */           log("the same permission is requesting");       } else {           /** 将当前权限请求加入队列 */           /** 如果一个页面中存在分别触发A, B多个权限的情况, 则最好将不同权限申请对应不同的requestCode, 存入SparseArray分别处理 */           mPermissionRequestList.put(requestCode, listener);           /** 执行权限申请 */           ActivityCompat.requestPermissions();       }   }}在权限回调的时候从SparseArray移除Listenerpublic static void onRequestPermissionsResult(Context context, int requestCode, String[] permissions,                                                  int[] grantResults) {   final OnPermissionListener listener;   synchronized (mPermissionRequestList) {       listener = mPermissionRequestList.get(requestCode);       mPermissionRequestList.remove(requestCode);   }   if (null != listener) {       /** 执行回调 */       listener.onGrant();       listener.onDeny();       listener.onNeverAsk();       listener.always();   } else {       log("request is not exists");   }}代码地址：LsPermission除了基本的权限申请逻辑的封装以外，还写了类似微信，支付宝，百度地图等在启动页的权限申请Demo，算是PermissionUtil的简单运用。参考：Android 6.0 运行时权限处理完全解析Android 6.0 运行时权限管理最佳实践聊一聊Android 6.0的运行时权限官方：在运行时请求权限权限最佳做法]]></content>
      <categories>
        
          <category> android </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Android源码中的一种单例实现]]></title>
      <url>/android/2017/01/12/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%B8%80%E7%A7%8D%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0/</url>
      <content type="text"><![CDATA[package android.util;/** * Singleton helper class for lazily initialization. * * Modeled after frameworks/base/include/utils/Singleton.h * * @hide */public abstract class Singleton&lt;T&gt; {    private T mInstance;    protected abstract T create();    public final T get() {        synchronized (this) {            if (mInstance == null) {                mInstance = create();            }            return mInstance;        }    }}     正常懒汉单例public class SingletonDemo {    private static SingletonDemo mInstance;    public static final SingletonDemo get() {        synchronized (SingletonDemo.class) {            if (mInstance == null) {                mInstance = new SingletonDemo();            }            return mInstance;        }    }} 懒汉+双重校验单例public class SingletonDemo {    private static SingletonDemo mInstance;    public static final SingletonDemo get() {        if (mInstance == null) {            synchronized (SingletonDemo.class) {                if (mInstance == null) {                    mInstance = new SingletonDemo();                }            }        }        return mInstance;    }} 变种懒汉单例public class SingletonDemo {    public static final SingletonDemo get() {        return INSTANCE.get();    }    private static final Singleton&lt;SingletonDemo&gt; INSTANCE = new Singleton&lt;SingletonDemo&gt;() {        protected SingletonDemo create() {            return new SingletonDemo();        }    };}懒汉式单例一般都会再加个双重校验的判断，避免每次调用get()都加锁，影响性能，Android源码中Singleton.java工具类并没有做双重校验（看了下googlesource中的Singleton.java，也是6年前提交的代码了），所以我们在将Singleton.java拷贝出来使用的时候可以加个双重校验优化下。Singleton.java封装了create，get模版，及get中的校验逻辑，从而SingletonDemo中的实现代码就可以更加的简单：1.create()一个单例对象，2.在需要的时候get()。]]></content>
      <categories>
        
          <category> android </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MVC，MVP，MVPVM（二）提升效率之Templates]]></title>
      <url>/android/2016/12/03/MVC-MVP-MVPVM-%E4%BA%8C-%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E4%B9%8BTemplates/</url>
      <content type="text"><![CDATA[#####解决方案  套用定义好的代码Templates，自动生成各个职能类。模版地址：https://github.com/listen2code/Test_MVPVM/tree/master/doc/MvpvmComponent#####使用介绍1.将写好的templates拷贝到本地Android Studio.app/Contents/plugins/android/lib/templates/activities/2.重启AndroidStudio，右键项目-&gt;New-&gt;Activity-&gt;MvpvmComponent3.在打开的编辑页面输入ActivityName和layoutName，包名为”com.listen.test_mvpvm”根据Templates自动生成的类&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"        xmlns:tools="http://schemas.android.com/tools"&gt;    &lt;data&gt;        &lt;variable name="data" type="com.listen.test_mvpvm.model.viewmodel.ITestMvpvmViewModel"/&gt;        &lt;variable name="presenter" type="com.listen.test_mvpvm.presenter.ITestMvpvmPresenter"/&gt;    &lt;/data&gt;    &lt;LinearLayout        android:layout_width="match_parent"        android:layout_height="match_parent"        android:orientation="vertical"&gt;        &lt;TextView            android:id="@+id/tv_test"            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:layout_centerInParent="true"            android:text="@{data.text}"/&gt;        &lt;Button            android:id="@+id/btn_test"            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:layout_below="@id/tv_test"            android:onClick="@{presenter.onClickAction}"            android:text="@{data.buttonText}"/&gt;    &lt;/LinearLayout&gt;&lt;/layout&gt;public class TestMvpvmActivity extends AppCompatActivity implements ITestMvpvmView {    private ActivityTestMvpvmBinding mBinding;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        mBinding = DataBindingUtil.setContentView(this, R.layout.activity_test_mvpvm);        mBinding.setPresenter(new TestMvpvmPresenter(this));    }    @Override    public void updateView(ITestMvpvmViewModel viewModel) {        mBinding.setData(viewModel);    }}public class TestMvpvmPresenter implements OnTestMvpvmListener, ITestMvpvmPresenter {    private ITestMvpvmView mITestMvpvmView;    private ITestMvpvmRepository mTestMvpvmRepository;    public TestMvpvmPresenter(ITestMvpvmView iTestMvpvmView) {        this.mITestMvpvmView = iTestMvpvmView;        this.mTestMvpvmRepository = new TestMvpvmRepositoryImpl(this);    }    public void onClickAction(View v) {        mTestMvpvmRepository.method("");    }    public void onTestMvpvmLoadSuccess(TestMvpvmModel data) {        mITestMvpvmView.updateView(new TestMvpvmViewModel(data));    }    public void onTestMvpvmLoadFail(String errorMessage) {    }}public class TestMvpvmRepositoryImpl implements ITestMvpvmRepository {    private OnTestMvpvmListener mOnTestMvpvmListener;    public TestMvpvmRepositoryImpl(OnTestMvpvmListener onTestMvpvmListener) {        this.mOnTestMvpvmListener = onTestMvpvmListener;    }    public void method(String param) {        new HttpTask() {            @Override            public void onRequestSuccess(TestMvpvmModel model) {                mOnTestMvpvmListener.onTestMvpvmLoadSuccess(model);            }        }.path("http://xxxx/getMydeposit").execute();    }}#####Templates介绍Templates由3个xml描述文件，和一堆.flt文件组成。globals.xml.ftl：主要用于定义一些全局变量，正常如果要自定义模版的话，globals文件可以直接拷贝过去，不需要什么改动。&lt;?xml version="1.0"?&gt;&lt;globals&gt;    &lt;global id="hasNoActionBar" type="boolean" value="false" /&gt;    &lt;global id="parentActivityClass" value="" /&gt;    &lt;global id="excludeMenu" type="boolean" value="true" /&gt;    &lt;global id="generateActivityTitle" type="boolean" value="false" /&gt;    &lt;#include "../common/common_globals.xml.ftl" /&gt;&lt;/globals&gt;template.xml：我们在新建模版时，会有个填写信息的页面，template文件主要用于描述该页面上的元素信息。&lt;template    format="5"    revision="8"    name="MvpvmComponent"    minApi="7"    minBuildApi="14"    description="Creates mvpvm components"&gt;    &lt;category value="Activity" /&gt;    &lt;formfactor value="Mobile" /&gt;    &lt;!-- 上图中第一个"Component Name"输入框的描述 --&gt;    &lt;parameter        id="activityClass"// 唯一性ID，后面会在.flt中引用        name="Component Name"// 输入框前的描述提示语        type="string"// 输入值类型        constraints="class|unique|nonempty"        suggest="${layoutToActivity(activityLayoutName)}"// 输入约束        default="Mvpvm"// 默认输入值        help="The name of the component" /&gt;//底部提示语    &lt;parameter        id="activityLayoutName"        name="Layout Name"        type="string"        constraints="layout|unique|nonempty"        suggest="${activityToLayout(activityClass)}"        default="activity_mvp"        help="The name of the layout" /&gt;    &lt;parameter        id="isLauncher"        name="Launcher Activity"        type="boolean"        default="false"        help="If true, this activity will have a CATEGORY_LAUNCHER intent filter, making it visible in the launcher" /&gt;        &lt;parameter        id="packageName"        name="Package name"        type="string"        constraints="package"        suggest="com.listen.test_mvpvm"        default="com.listen.test_mvpvm" /&gt;    &lt;globals file="globals.xml.ftl" /&gt;    &lt;execute file="recipe.xml.ftl" /&gt;&lt;/template&gt;recipe.xml.flt：将root目录下的.flt文件解析成.java文件，并打开。&lt;?xml version="1.0"?&gt;&lt;recipe&gt;	&lt;!-- 处理模版 --&gt;	&lt;instantiate from="root/src/app_package/MvpActivity.java.ftl"     	to="${escapeXmlAttribute(srcOut)}/view/${activityClass}Activity.java" /&gt;	&lt;!-- 打开xin --&gt; 	&lt;open file="${escapeXmlAttribute(srcOut)}/view/${activityClass}Activity.java" /&gt;&lt;/recipe&gt;MvpActivity.java.flt文件示例，引用template中的“@{activityClass}”，”${activityLayoutName}”，就是在输入页面填写的ActivityName，和layoutName。将”@{}”解析后生成完整的Activity.java。其实Templates的原理，就是将你需要生成的java文件的公用部分抽取出来，用”@{}”占位符，替代会变化的keyWord，写成一个个.flt模版文件，同时在输入面板中将keyWord输入，并通过template.xml，recipe.xml等描述文件，最终合成我们需要的java文件。public class ${activityClass}Activity extends AppCompatActivity implements I${activityClass}View {    private Activity${activityClass}Binding mBinding;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        mBinding = DataBindingUtil.setContentView(this, R.layout.${activityLayoutName});        mBinding.setPresenter(new ${activityClass}Presenter(this));    }    @Override    public void updateView(I${activityClass}ViewModel viewModel) {        mBinding.setData(viewModel);    }}通过定义Templates，在每次新建一个页面时节省了大量重复的类创建工作，我们可以运用Templates定义各种页面模版，可以大幅度的提升开发效率。在日常工作中，应该尽可能减少一些纯体力的，重复的代码拷贝。不过为优化，为解耦而增加再多类，分再多模块都是值得的。  Templates更详细介绍可以参考鸿洋的文章，这里不做赘述：http://blog.csdn.net/lmj623565791/article/details/51635533]]></content>
      <categories>
        
          <category> android </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MVC，MVP，MVPVM（一）实践之路]]></title>
      <url>/android/2016/12/01/MVC-MVP-MVPVM-%E4%B8%80-%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/</url>
      <content type="text"><![CDATA[#####简介  分别使用MVC，MVP，MVP+VM，实践具体需求，对比优劣，逐步优化。#####需求  实现我的押金页面，包含未缴纳，已缴纳，免押金3种状态1.顶部title：3种状态展示不同文案；2.金额：已缴纳，未缴纳状态金额字号，色值不同；免押金状态不展示；3.底部tips：已缴纳，免押金状态展示不同文案；已缴纳状态，不展示；4.按钮：未缴纳，已缴纳状态，文案，及点击事件都不相同；#####MVC的实现方式activity_main.xml&lt;LinearLayout            xmlns:android="http://schemas.android.com/apk/res/android"            xmlns:tools="http://schemas.android.com/tools"            android:layout_width="match_parent"            android:layout_height="match_parent"            android:orientation="vertical"            android:paddingLeft="30dp"            android:paddingRight="30dp"            tools:context="com.listen.test_mvc.MainActivity"&gt;                    &lt;TextView                android:id="@+id/tv_title"                android:layout_width="wrap_content"                android:layout_height="wrap_content"                android:layout_marginTop="50dp"                android:textColor="@android:color/black"                android:textSize="20sp"                tools:text="您需要缴纳押金"/&gt;                    &lt;TextView                android:id="@+id/tv_money"                android:layout_width="wrap_content"                android:layout_height="wrap_content"                android:layout_marginBottom="50dp"                android:layout_marginTop="50dp"                android:textColor="@android:color/darker_gray"                android:textSize="40sp"                tools:text="¥200"/&gt;                    &lt;TextView                android:id="@+id/tv_tips"                android:layout_width="wrap_content"                android:layout_height="wrap_content"                android:textColor="@android:color/black"                android:textSize="16sp"                tools:text="押金随时可退"/&gt;                    &lt;Button                android:id="@+id/btn_pay_or_return"                android:layout_width="match_parent"                android:layout_height="wrap_content"                android:layout_marginLeft="30dp"                android:layout_marginRight="30dp"                android:layout_marginTop="100dp"                android:textColor="@android:color/black"                android:textSize="16sp"                tools:text="缴纳押金"/&gt;        &lt;/LinearLayout&gt;在MainActivity中通过butterKnife框架初始化viewpublic class MainActivity extends AppCompatActivity {    @BindView(R.id.tv_title)    TextView mTvTitle;    @BindView(R.id.tv_money)    TextView mTvMoney;    @BindView(R.id.tv_tips)    TextView mTvTips;    @BindView(R.id.btn_pay_or_return)    Button mBtnPayOrReturn;    ///////////////////////////////////////////////////////////////////////////    // 缴纳押金，退还押金的点击事件    ///////////////////////////////////////////////////////////////////////////    private View.OnClickListener mDepositPayClickListener = new View.OnClickListener() {        @Override        public void onClick(View v) {            Toast.makeText(MainActivity.this, "缴纳押金", Toast.LENGTH_SHORT).show();        }    };    private View.OnClickListener mDepositReturnClickListener = new View.OnClickListener() {        @Override        public void onClick(View v) {            Toast.makeText(MainActivity.this, "退还押金", Toast.LENGTH_SHORT).show();        }    };        @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        ButterKnife.bind(this);    }}定义IDepositRepository封装数据获取逻辑（server，sqlite），此处模拟网络请求public interface IDepositRepository {    void getDepositInfo();}public interface OnDepositLoadListener {    void onLoadDepositSuccess(MyDepositModel model);}public class DepositRepositoryImpl implements IDepositRepository {    private OnDepositLoadListener mOnDepositLoadListener;    public DepositRepositoryImpl(OnDepositLoadListener onDepositLoadListener) {        mOnDepositLoadListener = onDepositLoadListener;    }    public void getDepositInfo() {        new HttpTask() {            @Override            public void onRequestSuccess(MyDepositModel model) {                mOnDepositLoadListener.onLoadDepositSuccess(model);            }        }.path("http://xxxx/getMydeposit").execute();    }}MyDepositModel用于存储数据public class MyDepositModel {    public String moneyPaied;// 已经缴纳押金时，该字段表示已经缴纳的金额    public String moneyNeed; // 未缴纳押金时，该字段表示需要缴纳的金额    public String isDepositPay;// 是否缴纳押金，1：是，0：否    public String isAuth; // 是否实名认证，1：是，0：否    public static MyDepositModel mock() {        MyDepositModel model = new MyDepositModel();        model.moneyPaied = "200.00";        model.moneyNeed = "300.00";        model.isDepositPay = "0";        model.isAuth = "0";        return model;    }    public boolean isDepositPay() {        return "1".equals(isDepositPay);    }    public boolean isAuth() {        return "1".equals(isAuth);    }}在MainActivity中调用IDepositRepository请求数据，通过OnDepositLoadListener获取请求成功后的数据，根据数据展示不同的viewpublic class MainActivity extends AppCompatActivity implements OnDepositLoadListener {    @BindView(R.id.tv_title)    TextView mTvTitle;    @BindView(R.id.tv_money)    TextView mTvMoney;    @BindView(R.id.tv_tips)    TextView mTvTips;    @BindView(R.id.btn_pay_or_return)    Button mBtnPayOrReturn;        private IDepositRepository mIDepositRepositoryImpl;    ///////////////////////////////////////////////////////////////////////////    // 缴纳押金，退还押金的点击事件    ///////////////////////////////////////////////////////////////////////////    private View.OnClickListener mDepositPayClickListener = new View.OnClickListener() {        @Override        public void onClick(View v) {            Toast.makeText(MainActivity.this, "缴纳押金", Toast.LENGTH_SHORT).show();        }    };    private View.OnClickListener mDepositReturnClickListener = new View.OnClickListener() {        @Override        public void onClick(View v) {            Toast.makeText(MainActivity.this, "退还押金", Toast.LENGTH_SHORT).show();        }    };    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        ButterKnife.bind(this);        mIDepositRepositoryImpl = new DepositRepositoryImpl(this);        requestData();    }    ///////////////////////////////////////////////////////////////////////////    // 模拟请求网络数据    ///////////////////////////////////////////////////////////////////////////    private void requestData() {        mIDepositRepositoryImpl.getDepositInfo();    }    ///////////////////////////////////////////////////////////////////////////    // 请求数据后的回调    ///////////////////////////////////////////////////////////////////////////    @Override    public void onLoadDepositSuccess(MyDepositModel model) {        showMydepositView(model);    }    ///////////////////////////////////////////////////////////////////////////    // 根据数据的不同状态展示不同的view    ///////////////////////////////////////////////////////////////////////////    private void showMydepositView(MyDepositModel model) {        if (model.isAuth()) {            // 已经实名认证            showAuthView();        } else if (model.isDepositPay()) {            // 已经缴纳押金            showDepositPaiedView(model);        } else {            // 未缴纳押金            showDepositNoPaiedView(model);        }    }    ///////////////////////////////////////////////////////////////////////////    // 展示未缴纳押金view    ///////////////////////////////////////////////////////////////////////////    private void showDepositNoPaiedView(MyDepositModel model) {        // title        mTvTitle.setText("您需要缴纳押金");        // money    mTvMoney.setTextColor(getResources().getColor(android.R.color.darker_gray));        mTvMoney.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 30);        mTvMoney.setText("¥ " +model.moneyNeed);        // tips        mTvTips.setText("押金随时可退");        //button        mBtnPayOrReturn.setText("缴纳押金");        mBtnPayOrReturn.setOnClickListener(mDepositPayClickListener);    }    ///////////////////////////////////////////////////////////////////////////    // 展示缴纳押金view    ///////////////////////////////////////////////////////////////////////////    private void showDepositPaiedView(MyDepositModel model) {        // title        mTvTitle.setText("您当前押金");        // moneymTvMoney.setTextColor(getResources().getColor(android.R.color.holo_red_light));        mTvMoney.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 40);        mTvMoney.setText("¥ " + model.moneyPaied);        // tips        mTvTips.setVisibility(View.INVISIBLE);        //button        mBtnPayOrReturn.setText("退还押金");        mBtnPayOrReturn.setOnClickListener(mDepositReturnClickListener);    }    ///////////////////////////////////////////////////////////////////////////    // 展示已实名认证view    ///////////////////////////////////////////////////////////////////////////    private void showAuthView() {        // title        mTvTitle.setText("您已享受免押金服务");        // money        mTvMoney.setVisibility(View.INVISIBLE);        // tips        mTvTips.setText("您已完成实名认证");        //button        mBtnPayOrReturn.setVisibility(View.INVISIBLE);    }}效果图项目结构：model：MydepositModel作为数据的载体，Repository负责从网络获取数据，两者共同承担着model的职责；view：activity_main.xml负责view的展示形式；control：MainActivity负责接收view的交互请求，提交给model；当model发生变化时操作view，更新展示逻辑。Activity：view的容器，控制生命周期，页面交互与事件处理xml：view展示与布局view逻辑：操作view进行更新，如setText，setVisible等业务逻辑：model更新，根据返回数据，执行逻辑主线，如：已/未缴纳/已认证Repository：数据中心（server，sqlite）model：存储数据交互逻辑：用户操作view，产生事件与数据，反向传递给model进行处理，如setOnclick，或在EditText中输入内容提交server等######总结：xml作为view层，控制能力太弱，如果要去动态的改变一个Textview的字号，色值，或者隐藏/显示一个按钮，这些都没办法在xml中做，只能把代码写在Activity中。MyDepositModel以后，需要根据isAuth，isDepositPaied等业务逻辑，控制view的展示。造成了Activity既是view层，又是controller层，导致代码膨胀，当业务复杂度继续增加时，一个Activity上千行代码是很常见的，大量逻辑参与其中，维护及代码阅读难度将不断提升。view和model直接交互，如：mTvMoney.setText(model.moneyNeed)，耦合较重，无法独立变化。mTvMoney作为一个Textview，只需要提供通过setText方法将String设置到TextView上进行展示的一种能力，至于这个String是从model1，还是model2中获取的，mTvMoney并不关心，而model作为数据源，也同样不需要关心当前是展示在mTvMoney上，还是mTvTips上。mBtnPayOrReturn按钮也是一样，只需提供一种点击响应的能力，至于点击后是操作缴纳押金，还是退还押金，mBtnPayOrReturn并不关心。#####MVP的实现方式1  在view和model之间新增presenter作为沟通的桥梁，presenter从model获取数据后，更新view的展示，使得view和model之间没有耦合，也将业务逻辑从view上抽离出来。实现MainPresenter，持有IMainView，IDepositRepository成员变量，获取数据，根据业务逻辑更新view的展示。public interface IMainPresenter {    /**     * @desc 进入页面后刷新数据     */    void requestData();    /**     * @desc 点击按钮     */    void onButtonClickAction();}/** * @author listen * @desc 主页面的presenter */public class MainPresenter implements IMainPresenter, OnDepositLoadListener {    private IMainView mIMainView;    private IDepositRepository mIDepositRepositoryImpl;    private MyDepositModel mModel;    public MainPresenter(IMainView iMainView) {        mIMainView = iMainView;        mIDepositRepositoryImpl = new DepositRepositoryImpl(this);    }    @Override    public void requestData() {        mIDepositRepositoryImpl.getDepositInfo();    }    /**     * @desc 实现OnDepositLoadListener回调，获取MyDepositModel，并根据业务逻辑更新view的展示     */    @Override    public void onLoadDepositSuccess(MyDepositModel model) {        if (model.isAuth()) {            // 已经实名认证            showAuthView();        } else if (model.isDepositPay()) {            // 已经缴纳押金            showDepositPaiedView(model);        } else {            // 未缴纳押金            showDepositNoPaiedView(model);        }    }    /**     * @desc 未支付状态view     */    private void showDepositNoPaiedView(MyDepositModel model) {        // title        mIMainView.setTitleText("您需要缴纳押金"); // 不暴露mTvTitle，只提供设置title文案的能力        // money        mIMainView.setMoneyTextVisible();// 提供操作MoneyText显示/隐藏的能力        mIMainView.setMoneyTextColorGray();// 提供MoneyText字体设置为灰色的能力        mIMainView.setMoneyTextSizeSmall();// 提供MoneyText字号设置小的能力        mIMainView.setMoneyText("¥ " + model.moneyNeed);// 提供设置MoneyText文案的能力        // tips        mIMainView.setTipsTextVisible();// 提供操作TipsText显示/隐藏的能力        mIMainView.setTipsText("押金随时可退");// 提供设置TipsText文案的能力        //button        mIMainView.setButtonVisible();// 提供操作Button显示/隐藏的能力        mIMainView.setButtonText("缴纳押金");// 提供设置Button文案的能力    }    /**     * @desc 支付状态view     */    private void showDepositPaiedView(MyDepositModel model) {        // title        mIMainView.setTitleText("您当前押金");        // money        mIMainView.setMoneyTextVisible();        mIMainView.setMoneyTextColorRed();        mIMainView.setMoneyTextSizeBig();        mIMainView.setMoneyText("¥ " + model.moneyNeed);        // tips        mIMainView.setTipsTextInvisible();        //button        mIMainView.setButtonVisible();        mIMainView.setButtonText("退还押金");    }    /**     * @desc 实名认证状态view     */    private void showAuthView() {        // title        mIMainView.setTitleText("您已享受免押金服务");        // money        mIMainView.setMoneyTextInvisible();        // tips        mIMainView.setTipsTextVisible();        mIMainView.setTipsText("您已完成实名认证");        //button        mIMainView.setButtonInvisible();    }    /**     * @desc 当点击Button时触发的操作     */    @Override    public void onButtonClickAction() {        if (mModel.isDepositPay()) {            mIMainView.showToast("退还押金");        } else {            mIMainView.showToast("缴纳押金");        }    }}实现view层/** * @author listen * @desc 主页面view层接口 */public interface IMainView {    void setTitleText(String text);        void setMoneyTextColorGray();    void setMoneyTextSizeSmall();    void setMoneyText(String text);    void setMoneyTextInvisible();    void setMoneyTextVisible();    void setMoneyTextColorRed();    void setMoneyTextSizeBig();        void setTipsText(String text);    void setTipsTextInvisible();    void setTipsTextVisible();        void setButtonText(String text);    void setButtonInvisible();    void setButtonVisible();        void showToast(String text);}public class MainActivity extends AppCompatActivity implements IMainView {    @BindView(R.id.tv_title)    TextView mTvTitle;    @BindView(R.id.tv_money)    TextView mTvMoney;    @BindView(R.id.tv_tips)    TextView mTvTips;    @BindView(R.id.btn_pay_or_return)    Button mBtnPayOrReturn;    private IMainPresenter mPresenter;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        ButterKnife.bind(this);        mPresenter = new MainPresenter(this);        mPresenter.requestData();        mBtnPayOrReturn.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                mPresenter.onButtonClickAction();            }        });    }    @Override    public void setTitleText(String text) {        mTvTitle.setText(text);    }    @Override    public void setMoneyTextColorGray() {        mTvMoney.setTextColor(getResources().getColor(android.R.color.darker_gray));    }    @Override    public void setMoneyTextColorRed() {        mTvMoney.setTextColor(getResources().getColor(android.R.color.holo_red_light));    }    @Override    public void setMoneyTextSizeSmall() {        mTvMoney.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 30);    }    @Override    public void setMoneyTextSizeBig() {        mTvMoney.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 40);    }    @Override    public void setMoneyText(String text) {        mTvMoney.setText(text);    }    @Override    public void setMoneyTextInvisible() {        mTvMoney.setVisibility(View.VISIBLE);    }    @Override    public void setMoneyTextVisible() {        mTvMoney.setVisibility(View.VISIBLE);    }    @Override    public void setTipsText(String text) {        mTvTips.setText(text);    }    @Override    public void setTipsTextInvisible() {        mTvTips.setVisibility(View.INVISIBLE);    }    @Override    public void setTipsTextVisible() {        mTvTips.setVisibility(View.VISIBLE);    }    @Override    public void setButtonText(String text) {        mBtnPayOrReturn.setText(text);    }    @Override    public void setButtonInvisible() {        mBtnPayOrReturn.setVisibility(View.INVISIBLE);    }    @Override    public void setButtonVisible() {        mBtnPayOrReturn.setVisibility(View.VISIBLE);    }    @Override    public void showToast(String text) {        Toast.makeText(this, text, Toast.LENGTH_SHORT).show();    }}######总结presenter处理业务逻辑并更新view，Activity只提供基础的操作view的能力，2者互相独立，view与业务分离。业务变化1：不管已缴纳，未缴纳，免押金任何状态tipsText都不显示，此时就不需要去修改Activity，直接在presenter设置mIMainView.setTipsTextVisible()即可；业务变化2：新增一种状态，已实名认证，不过某些条件不满足，押金不能全免，只能减半，titleText显示”已认证，还需缴纳押金”，moneyText大号字体，红色，tipsText显示”押金已减半”，Button显示文案”补足押金”，这种场景下，就不用去修改Activity的任何代码，只要在presenter新增逻辑分支，根据view提供的能力进行更新即可。/** * @desc 押金减半状态view */private void showDepositHalfPayView(MyDepositModel model) {   // title   mIMainView.setTitleText("已认证，还需缴纳押金");   // money   mIMainView.setMoneyTextVisible();   mIMainView.setMoneyTextColorRed();   mIMainView.setMoneyTextSizeBig();   mIMainView.setMoneyText("¥ " + model.moneyNeed);   // tips   mIMainView.setTipsTextVisible();   mIMainView.setTipsText("押金已减半");   //button   mIMainView.setButtonVisible();   mIMainView.setButtonText("补足押金");}/** * @desc 押金减半时，button的点击响应 */public void onButtonClickAction() {        if ("押金减半") {            mIMainView.showToast("补足押金");        }     }业务变化3：presenter依赖的是IMainView，不管是MainActivity，还是Main1Activity，只要是实现了IMainView即可复用当前presenter。当我们把业务逻辑抽取到presenter后，Activity基本上只剩下一些view的逻辑，真正实现了减负，变成了一个相对纯净的view。当我们需要修改view的逻辑时，就去找Activity，需要修改数据逻辑时，就去找Repository，修改业务逻辑时就去找presenter，每个模块职责分明。缺点：1.view与presenter之间交互过于频繁，Activity中都是一些setText，setVisibility等方法。这时很容易让人想到使用Databinding可以很好的简化这部分代码。#####MVP的实现方式2  通过DataBinding实现model到view的单向绑定，减少view与model之间因频繁交互而产生的冗余代码。在标签中引入data=MyDepositModel，presenter=IMainPresenter。当model变化时，通过data将数据映射到view上。当Button产生点击事件时交由presenter响应并处理。使用Databinding以后，开发流程上省略了findView，setView的过程，在写xml的时候就可以直接将model进行关联及映射。&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout    xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:tools="http://schemas.android.com/tools"&gt;    &lt;data&gt;        &lt;variable name="data" type="com.listen.test_mvvm.model.data.MyDepositModel"/&gt;        &lt;variable name="presenter" type="com.listen.test_mvvm.presenter.IMainPresenter"/&gt;        &lt;import type="android.view.View"/&gt;    &lt;/data&gt;    &lt;LinearLayout        android:layout_width="match_parent"        android:layout_height="match_parent"        android:orientation="vertical"        android:paddingLeft="30dp"        android:paddingRight="30dp"        tools:context="com.listen.test_mvvm.view.MainActivity"&gt;        &lt;TextView            android:id="@+id/tv_title"            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:layout_marginTop="50dp"            android:textColor="@android:color/black"            android:textSize="20sp"            android:text="@{data.title}"/&gt;        &lt;TextView            android:id="@+id/tv_money"            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:layout_marginBottom="50dp"            android:layout_marginTop="50dp"            android:textColor="@{data.isDepositPay ? @android:color/holo_red_light : @android:color/darker_gray}"            android:textSize="@{data.isDepositPay ? @dimen/sp_40 : @dimen/sp_30}"            android:visibility="@{data.isAuth ? View.INVISIBLE : View.VISIBLE}"            android:text="@{data.money}"/&gt;        &lt;TextView            android:id="@+id/tv_tips"            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:textColor="@android:color/black"            android:textSize="16sp"            android:visibility="@{data.showTips ? View.VISIBLE : View.INVISIBLE}"            android:text="@{data.tips}"/&gt;        &lt;Button            android:id="@+id/btn_pay_or_return"            android:layout_width="match_parent"            android:layout_height="wrap_content"            android:layout_marginLeft="30dp"            android:layout_marginRight="30dp"            android:layout_marginTop="100dp"            android:onClick="@{presenter.onButtonClickAction}"            android:visibility="@{data.isAuth ? View.INVISIBLE : View.VISIBLE}"            android:textColor="@android:color/black"            android:textSize="16sp"            android:text='@{data.isDepositPay ? "退还押金" : "缴纳押金"}'/&gt;    &lt;/LinearLayout&gt;&lt;/layout&gt;将业务逻辑转移到MyDepositModelpublic class MyDepositModel {    public String moneyPaied;// 已经缴纳押金时，该字段表示已经缴纳的金额    public String moneyNeed; // 未缴纳押金时，该字段表示需要缴纳的金额    public String isDepositPay;// 是否缴纳押金，1：是，0：否    public String isAuth; // 是否实名认证，1：是，0：否    public boolean isDepositPay() {        return "1".equals(isDepositPay);    }    public boolean isAuth() {        return "1".equals(isAuth);    }    public String getTitle() {        if (isAuth()) {            return "您已享受免押金服务";        }        if (isDepositPay()) {            return "您当前押金";        } else {            return "您需要缴纳押金";        }    }    public String getMoney() {        if (isDepositPay()) {            return "¥ " + moneyPaied;        } else {            return "¥ " + moneyNeed;        }    }    public String getTips() {        if (isAuth()) {            return "您已完成实名认证";        }        if (!isDepositPay()) {            return "押金随时可退";        }        return "";    }    public boolean isShowTips() {        if (isAuth() || !isDepositPay()) {            return true;        }        return false;    }}MainPresenter不再与view频繁的交互，仅仅是作为view和model的连接器，主干逻辑更为清晰public class MainPresenter implements IMainPresenter, OnDepositLoadListener {    private IMainView mIMainView;    private IDepositRepository mIDepositRepository;    private MyDepositModel mModel;    public MainPresenter(IMainView iMainView) {        mIMainView = iMainView;        mIDepositRepository = new DepositRepository(this);    }    // 请求数据    @Override    public void requestData() {        mIDepositRepository.getDepositInfo();    }    // 获取数据，通知view更新    @Override    public void onLoadDepositSuccess(MyDepositModel model) {        mModel = model;        mIMainView.updateData(model);    }    // 接收并处理view的点击事件    @Override    public void onButtonClickAction(View v) {        if (mModel.isDepositPay()) {            mIMainView.showToast("退还押金");        } else {            mIMainView.showToast("缴纳押金");        }    }}MainActivity中不再需要fingViewById，也不用定义Textview，Button的成员变量，全部交由DataBinding进行处理，相较MVP的实现，MainActivity进一步简化public class MainActivity extends AppCompatActivity implements IMainView {    private IMainPresenter mPresenter;    private ActivityMainBinding mBinding;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        mBinding = DataBindingUtil.setContentView(this, R.layout.activity_main);        mPresenter = new MainPresenter(this);        mBinding.setPresenter(mPresenter);                // 初始化页面数据        mPresenter.requestData();    }    // 更新数据绑定    @Override    public void updateData(MyDepositModel model) {        mBinding.setData(model);    }    // 提供Toast提示的能力    @Override    public void showToast(String text) {        Toast.makeText(this, text, Toast.LENGTH_SHORT).show();    }}IMainView接口也不再需要提供那么多操作view的方法public interface IMainView {    void updateData(MyDepositModel model);    void showToast(String text);}问题：1.xml中参杂了一些业务逻辑，如：data.isDepositPay，data.isAuth，xml中应该尽量只是简单的view逻辑，与业务逻辑隔离。2.由于使用databinding是model-&gt;view的单向绑定，不得不将大部分逻辑搬移到model中，例如：MyDepositModel中即有数据处理逻辑，isDepositPay，isAuth（如果model中存在list等，经常会对外提供getItemById(int id)等方法，做遍历查询）。同时还存在view的展示逻辑，例：isShowTips，getTitle，getMoney，这些方法都是根据数据变化控制view的展示，两者之间其实还是有比较明确的分界线，可以进一步分离，解耦，避免model过重。#####MVPVM的实现方式  通过viewModel作为model和view的适配层，model只负责数据存储activity_main.xml中将原先的model.isDepositPay()，model.isAuth()改成viewModel.moneyTextVisible()，viewModel.moneyTextSizeLarge()等。在xml中依赖viewModel，只关心view显示/隐藏，字号变大/小，色值高亮/正常，至于什么情况下展示高亮，是否显示由viewModel中适配的model逻辑决定。&lt;layout    xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:tools="http://schemas.android.com/tools"&gt;    &lt;data&gt;        &lt;variable name="data" type="com.listen.test_mvvm.model.viewmodel.IMyDepositViewModel"/&gt;        &lt;variable name="presenter" type="com.listen.test_mvvm.presenter.IMainPresenter"/&gt;        &lt;import type="android.view.View"/&gt;    &lt;/data&gt;    &lt;LinearLayout        android:layout_width="match_parent"        android:layout_height="match_parent"        android:orientation="vertical"        android:paddingLeft="30dp"        android:paddingRight="30dp"        tools:context="com.listen.test_mvvm.view.MainActivity"&gt;        &lt;TextView            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:layout_marginTop="50dp"            android:text="@{data.title}"            android:textColor="@android:color/black"            android:textSize="20sp"/&gt;        &lt;TextView            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:layout_marginBottom="50dp"            android:layout_marginTop="50dp"            android:text="@{data.money}"            android:textColor="@{data.moneyTextColorHightLight ? @android:color/holo_red_light : @android:color/darker_gray}"            android:textSize="@{data.moneyTextSizeLarge ? @dimen/sp_40 : @dimen/sp_30}"            android:visibility="@{data.moneyTextVisible ? View.VISIBLE : View.INVISIBLE}"/&gt;        &lt;TextView            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text="@{data.tips}"            android:textColor="@android:color/black"            android:textSize="16sp"            android:visibility="@{data.tipsVisible ? View.VISIBLE : View.INVISIBLE}"/&gt;        &lt;Button            android:layout_width="match_parent"            android:layout_height="wrap_content"            android:layout_marginLeft="30dp"            android:layout_marginRight="30dp"            android:layout_marginTop="100dp"            android:onClick="@{presenter.onButtonClickAction}"            android:text="@{data.buttonText}"            android:textColor="@android:color/black"            android:textSize="16sp"            android:visibility="@{data.buttonVisible ? View.VISIBLE : View.INVISIBLE}"/&gt;    &lt;/LinearLayout&gt;&lt;/layout&gt;IMyDepositViewModel接口，定义view提供的能力public interface IMyDepositViewModel {    String getTitle();    boolean isMoneyTextColorHightLight();    boolean isMoneyTextSizeLarge();    boolean isMoneyTextVisible();    String getMoney();    boolean isTipsVisible();    String getTips();    boolean isButtonVisible();    String getButtonText();}MyDepositBaseViewModel实现IMyDepositViewModel的默认展示逻辑public abstract class MyDepositBaseViewModel implements IMyDepositViewModel {    private MyDepositModel mModel;    public MyDepositBaseViewModel(MyDepositModel model) {        mModel = model;    }    public MyDepositModel getModel() {        return mModel;    }    @Override    public String getTitle() {        return "";    }    @Override    public boolean isMoneyTextColorHightLight() {        return false;    }    @Override    public boolean isMoneyTextSizeLarge() {        return false;    }    @Override    public boolean isMoneyTextVisible() {        return false;    }    @Override    public String getMoney() {        return "";    }    @Override    public boolean isTipsVisible() {        return false;    }    @Override    public String getTips() {        return "";    }    @Override    public boolean isButtonVisible() {        return false;    }    @Override    public String getButtonText() {        return "";    }}已缴纳押金时viewModel的展示逻辑public class MyDepositPayViewModel extends MyDepositBaseViewModel {    public MyDepositPayViewModel(MyDepositModel model) {        super(model);    }    @Override    public String getTitle() {        return "您当前押金";    }    @Override    public String getMoney() {        return "¥ " + getModel().moneyPaied;    }    @Override    public boolean isMoneyTextVisible() {        return true;    }    @Override    public boolean isMoneyTextColorHightLight() {        return true;    }    @Override    public boolean isMoneyTextSizeLarge() {        return true;    }    @Override    public boolean isButtonVisible() {        return true;    }    @Override    public String getButtonText() {        return "退还押金";    }}未缴纳押金时viewModel的展示逻辑public class MyDepositNoPayViewModel extends MyDepositBaseViewModel {    public MyDepositNoPayViewModel(MyDepositModel model) {        super(model);    }    @Override    public String getTitle() {        return "您需要缴纳押金";    }    @Override    public String getMoney() {        return "¥ " + getModel().moneyNeed;    }    @Override    public boolean isMoneyTextVisible() {        return true;    }    @Override    public boolean isMoneyTextColorHightLight() {        return false;    }    @Override    public boolean isMoneyTextSizeLarge() {        return false;    }    @Override    public boolean isButtonVisible() {        return true;    }    @Override    public boolean isTipsVisible() {        return true;    }    @Override    public String getTips() {        return "押金随时可退";    }    @Override    public String getButtonText() {        return "缴纳押金";    }}已认证时viewModel的展示逻辑public class MyDepositAuthViewModel extends MyDepositBaseViewModel {    public MyDepositAuthViewModel(MyDepositModel model) {        super(model);    }    @Override    public String getTitle() {        return "您已享受免押金服务";    }    @Override    public boolean isTipsVisible() {        return true;    }    @Override    public String getTips() {        return "您已完成实名认证";    }}MainPresenter获取数据后，根据不同业务逻辑展示MyDepositAuthViewModel，MyDepositPayViewModel，MyDepositNoPayViewModel。此处有点像设计模式中的策略模式，这3个viewModel就是view的不同展示策略的封装。public class MainPresenter implements IMainPresenter, OnDepositLoadListener {    private IMainView mIMainView;    private IDepositRepository mIDepositRepositoryImpl;    private MyDepositModel mModel;    public MainPresenter(IMainView iMainView) {        mIMainView = iMainView;        mIDepositRepositoryImpl = new DepositRepositoryImpl(this);    }    @Override    public void requestData() {        mIDepositRepositoryImpl.getDepositInfo();    }    @Override    public void onLoadDepositSuccess(MyDepositModel model) {        mModel = model;        if (mModel.isAuth()) {            mIMainView.updateData(new MyDepositAuthViewModel(model));        } else if (mModel.isDepositPay()) {            mIMainView.updateData(new MyDepositPayViewModel(model));        } else {            mIMainView.updateData(new MyDepositNoPayViewModel(model));        }    }    @Override    public void onButtonClickAction(View v) {        if (mModel.isDepositPay()) {            mIMainView.showToast("退还押金");        } else {            mIMainView.showToast("缴纳押金");        }    }}MainActivity.java，只做基本的数据请求，DataBinding初始化，toast提示等操纵。public class MainActivity extends AppCompatActivity implements IMainView {    private IMainPresenter mPresenter;    private ActivityMainBinding mBinding;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        mBinding = DataBindingUtil.setContentView(this, R.layout.activity_main);        mPresenter = new MainPresenter(this);        mBinding.setPresenter(mPresenter);        mPresenter.requestData();    }    @Override    public void updateData(IMyDepositViewModel viewModel) {        mBinding.setData(viewModel);    }    @Override    public void showToast(String text) {        Toast.makeText(this, text, Toast.LENGTH_SHORT).show();    }}如图：用户操作view，触发事件响应，通过presenter中转，传递给model进行数据处理，获取新数据后处理业务逻辑，并适配成不同状态的viewModel展示策略，view根据不同的viewModel进行更新。总结：从mvc到mvpvm，项目中类虽然变多了，不过模块之间职责更加明确清晰。大部分情况，使用mvp结合databinding就可以较好的对view和model进行解耦，且代码冗余较少，当然在页面逻辑简单的情况下，可能连Presenter都没有用上的必要。不过如果是类似本文中的需求，view状态相对复杂的情况下，最好还是经过一层viewModel适配，也可以释放model的压力，xml布局中只依赖抽象的IMyDepositViewModel（model-&gt;view的数据输入）和IMainPresenter（view-&gt;model的事件输出），不依赖具体。本文并非按照传统的MVC，MVP，MVVM的路线实现架构，而是采用循序渐进的方式，在MVC中发现Activity过重，所以引入MVP，Presenter作为View和Model的中转，达到解耦的目的。后来发现Activity提供view能力时冗余代码过多，所以引入DataBinding，虽然代码简化了，不过xml中引入了部分业务逻辑，model中同时参杂数据处理逻辑和view展示逻辑，故而引入viewModel，将xml与model进一步解耦，同时减轻model负担，不过此时并不算是mvvm，本质上在mvp的基础上，引入vm，因此presenter的中转作用还在，所以才演变成了现在的mvpvm。同时强调下，架构无绝对的好坏与绝对的标准，大家应该在项目中根据实际场景选择最合适的架构方式。本文中如有说明，解释不到位的地方，还请指出，互相学习共勉。最终版本项目地址：https://github.com/listen2code/Test_MVPVM]]></content>
      <categories>
        
          <category> android </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[DataBinding学习笔记（一）源码分析]]></title>
      <url>/android/2016/11/27/DataBinding%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="text"><![CDATA[###开发阶段#####UserModel.javapublic class UserModel {    public String name;    public String nickName;    public int age;    public UserModel(String name, String nickName, int age) {        this.name = name;        this.age = age;        this.nickName = nickName;    }    public boolean isAge18() {        return age &gt;= 18;    }}#####activity_main.xml  在xml中使用”@{}”标识符&lt;layout    xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:tools="http://schemas.android.com/tools"&gt;    &lt;data&gt;        &lt;variable name="user" type="com.listen.test_databinding.UserModel"/&gt;        &lt;variable name="testClick" type="android.view.View.OnClickListener"/&gt;        &lt;import type="android.view.View"/&gt;    &lt;/data&gt;    &lt;LinearLayout        android:layout_width="match_parent"        android:layout_height="match_parent"        android:orientation="vertical"        tools:context="com.listen.test_databinding.MainActivity"&gt;        &lt;TextView            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text='@{"名字" + user.name}'/&gt;        &lt;TextView            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text='@{user.nickName}'            android:visibility="@{null == user.nickName ? View.VISIBLE : View.GONE}"/&gt;        &lt;TextView            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text='@{user.isAge18() ? "man" : "boy"}'/&gt;        &lt;Button            android:id="@+id/btn_test"            android:layout_width="match_parent"            android:layout_height="50dp"            android:onClick="@{testClick}" android:text="测试"/&gt;    &lt;/LinearLayout&gt;&lt;/layout&gt;#####MainActivity.javapublic class MainActivity extends AppCompatActivity {    private ActivityMainBinding mBinding;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        mBinding = DataBindingUtil.setContentView(this, R.layout.activity_main);        final UserModel user = new UserModel("listen", "ls", 18);        mBinding.setUser(user);        mBinding.setTestClick(new View.OnClickListener() {            @Override            public void onClick(View view) {                Toast.makeText(MainActivity.this, "testClick", Toast.LENGTH_SHORT).show();            }        });    }}###编译阶段####1.Databinding会自动解析识别xml中的”@{}”标识符，并在以下目录生成2个xml文件  1.build/intermediates/data-binding-layout-out/activity_main.xml2.build/intermediates/data-binding-info/debug/activity_main-layout.xml######activity_main.xml  带“@{}”的xml文件是android系统无法识别的，为了向后兼容，需要在编译期统一转换成系统能识别的标准xml布局，而原先在布局中添加的”@{}”，”@{三目运算符}”等信息，则会存储在activity_main-layout.xml中。&lt;LinearLayout    xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"        android:orientation="vertical"    android:tag="layout/activity_main_0"    tools:context="com.listen.test_databinding.MainActivity"&gt;    &lt;TextView        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:tag="binding_1"/&gt;    &lt;TextView        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:tag="binding_2"    /&gt;    &lt;TextView        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:tag="binding_3"/&gt;    &lt;Button        android:id="@+id/btn_test"        android:layout_width="match_parent"        android:layout_height="50dp"        android:tag="binding_4" android:text="测试"/&gt;&lt;/LinearLayout&gt;######activity_main-layout.xml（xml描述文件）  1.任何view只要用到了”@{}”标识，就会在activity_main-layout.xml中生成target描述，并根据该view在parent中的位置生成”binding_[index]”标识，并设置在tag中。2.如果一个view即没有设置”android:id”，也没有使用”@{}”标识，则不会在activity_main-layout.xml中生成这个view的target描述。3.LinearLayout比较特殊，并没有设置”android:id”，也没有使用”@{}”，但还是会生成一个默认的tag=”layout/activity_main_0”，表示它是根布局，在ViewDataBinding.java实例化时，需要判断根布局的tag，后面源码会分析到。&lt;?xml version="1.0" encoding="utf-8" standalone="yes"?&gt;&lt;Layout absoluteFilePath="/Users/lisong/Documents/AndroidStudioWorkSpace/Test_Databinding/app/src/main/res/layout/activity_main.xml" directory="layout"        isMerge="false"        layout="activity_main" modulePackage="com.listen.test_databinding"&gt;    &lt;Variables name="user" declared="true" type="com.listen.test_databinding.UserModel"&gt;        ...    &lt;/Variables&gt;    &lt;Variables name="testClick" declared="true" type="android.view.View.OnClickListener"&gt;        ...    &lt;/Variables&gt;    &lt;Imports name="View" type="android.view.View"&gt;        ...    &lt;/Imports&gt;    &lt;Targets&gt;        &lt;Target tag="layout/activity_main_0" view="LinearLayout"&gt;            &lt;Expressions/&gt;            ...        &lt;/Target&gt;        &lt;Target tag="binding_1" view="TextView"&gt;            &lt;Expressions&gt;                &lt;Expression attribute="android:text" text=""名字" + user.name"&gt;                    ...                &lt;/Expression&gt;            &lt;/Expressions&gt;        &lt;/Target&gt;        &lt;Target tag="binding_2" view="TextView"&gt;            &lt;Expressions&gt;                &lt;Expression attribute="android:text" text="user.nickName"&gt;                    ...                &lt;/Expression&gt;                &lt;Expression attribute="android:visibility"                            text="null == user.nickName ? View.VISIBLE : View.GONE"&gt;                    ...                &lt;/Expression&gt;            &lt;/Expressions&gt;        &lt;/Target&gt;        &lt;Target tag="binding_3" view="TextView"&gt;            &lt;Expressions&gt;                &lt;Expression attribute="android:text"                            text="user.isAge18() ? "man" : "boy""&gt;                    ...                &lt;/Expression&gt;            &lt;/Expressions&gt;        &lt;/Target&gt;        &lt;Target id="@+id/btn_test" tag="binding_4" view="Button"&gt;            &lt;Expressions&gt;                &lt;Expression attribute="android:onClick" text="testClick"&gt;                    ...                &lt;/Expression&gt;            &lt;/Expressions&gt;        &lt;/Target&gt;    &lt;/Targets&gt;&lt;/Layout&gt;####2.生成ActivityMainBinding.java和BR.java  DataBinding根据解析后的activity_main-layout.xml，和layout下的activity_main.xml文件，生成build/intermediates/classes/debug/[项目路径]/databinding/ActivityMainBinding.java和BR.java######ActivityMainBinding主要具备以下功能  1.作为view和model的连接器，持有需要展示的数据和views的成员变量2.将数据映射到view（就是setText，setOnClick等）3.在UI线程更新数据######BR.java就是一个常量类  可以通过binding.setVariable(BRuser, new User())进行数据更新public class BR {    public static final int _all = 0;    public static final int testClick = 1;    public static final int user = 2;    public BR() {    }}public boolean setVariable(int variableId, Object variable) {    switch(variableId) {        case BR.testClick :            setTestClick((android.view.View.OnClickListener) variable);            return true;        case BR.user :            setUser((com.listen.test_databinding.UserModel) variable);            return true;    }    return false;}###运行阶段  Databinding框架最主要做的事，就是以上2步，接下来就是在代码中调用生成的ViewDataBinding，并进行数据绑定操作。######DataBindingUtil是一切的入口ActivityMainBinding mBinding = DataBindingUtil.setContentView(this, R.layout.activity_main);public static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId, DataBindingComponent bindingComponent) {    activity.setContentView(layoutId);// 最终调用的还是activity.setContentView()，不过这里的layoutId是已经去掉"@{}"的标准xml布局    View decorView = activity.getWindow().getDecorView();    ViewGroup contentView = (ViewGroup) decorView.findViewById(android.R.id.content);//获取根顶级容器view    return bindToAddedViews(bindingComponent, contentView, 0, layoutId);}######取出布局的rootView，调用ActivityMainBinding.bind()private static &lt;T extends ViewDataBinding&gt; T bindToAddedViews(android.databinding.DataBindingComponent component, ViewGroup parent, int startChildren, int layoutId) {    final int endChildren = parent.getChildCount();    final int childrenAdded = endChildren - startChildren;    if (childrenAdded == 1) {        // 从顶级容器view中获取当前布局的rootView，调用bind方法        final View childView = parent.getChildAt(endChildren - 1);        return bind(component, childView, layoutId);    } else {        ...    }}static &lt;T extends ViewDataBinding&gt; T bind(DataBindingComponent bindingComponent, View root,                                          int layoutId) {    // sMapper = DataBinderMapper.java    return (T) sMapper.getDataBinder(bindingComponent, root, layoutId);}/**  DataBinderMapper.java */public android.databinding.ViewDataBinding getDataBinder(android.databinding.DataBindingComponent bindingComponent, android.view.View view, int layoutId) {    switch(layoutId) {        case com.listen.test_databinding.R.layout.activity_main:            // 将rootView传递给ActivityMainBinding.bind()            return com.listen.test_databinding.databinding.ActivityMainBinding.bind(view, bindingComponent);    }    return null;}此处做了rootView的判断，如果传递过来的不是当前ViewDataBinding绑定的布局，则抛异常。所以即使rootView没有设置id，及”@{}”，在info-layout.xml中也会生成相应的target描述。public static ActivityMainBinding bind(View view, DataBindingComponent bindingComponent) {    if(!"layout/activity_main_0".equals(view.getTag())) {        throw new RuntimeException("view tag isn\'t correct on view:" + view.getTag());    } else {        return new ActivityMainBinding(bindingComponent, view); // ActivityMainBinding在此处初始化    }}这里需要特别注意的是在编译期自动生成的activity_main.xml文件中自动添加了tag=”binding_1”，”binding_2”等，其实在初始化完这些view后，都已经清空，是不影响我们在代码中设置tag的；不过rootView并没有清除tag（就是xml布局最外层的layout），如果&gt;=14以上版本，在代码里设置setTag(R.id.databinding,”anything”)，或，&lt;14版本，在代码里设置setTag(“anything”)，则会报错，so，这个tag是由DataBinding占着的，使用上得小心。public ActivityMainBinding(android.databinding.DataBindingComponent bindingComponent, View root) {    super(bindingComponent, root, 0);    // 遍历布局，找到所有views，并存储在bindings[]中，5表示布局一共有5个view，sIncludes存储被include进     // 来的布局，sViewsWithIds存储设置了"android:id"，但是没有用到"@{}"的view    Object[] bindings = mapBindings(bindingComponent, root, 5, sIncludes, sViewsWithIds);    // 将bindings[]中的view取出，赋值给当前各个view的成员变量，并清除tag，避免冲突    this.btnTest = (Button)bindings[4];    this.btnTest.setTag((Object)null);    this.mboundView0 = (LinearLayout)bindings[0];    this.mboundView0.setTag((Object)null);    this.mboundView1 = (TextView)bindings[1];    this.mboundView1.setTag((Object)null);    this.mboundView2 = (TextView)bindings[2];    this.mboundView2.setTag((Object)null);    this.mboundView3 = (TextView)bindings[3];    this.mboundView3.setTag((Object)null);    this.setRootTag(root);    /**    ViewDatabBinding.java    protected void setRootTag(View view) {        //private static final boolean USE_TAG_ID = DataBinderMapper.TARGET_MIN_SDK &gt;= 14;        if (USE_TAG_ID) {        view.setTag(R.id.dataBinding, this);        } else {        view.setTag(this);        }    }    */        // 请求刷新，实现数据与view的绑定    this.invalidateAll();}mapBindings()，其实就是递归遍历view树的过程，不过不是byId，而是byTag，寻找以”binding_“开头的view，并取出”binding_[索引]”中的索引，赋值给binding[]数组。所有的view只在一次遍历中获得，而如果是用findViewById的方式，每次调用都需要遍历一次view树[性能对比]。需要特别注意的是binding数组的元素不一定都是view或viewGroup，如果有include布局的时候binding数组存储的可能是include布局的viewDataBinding对象。private static void mapBindings(DataBindingComponent bindingComponent, View view, Object[] bindings, ViewDataBinding.IncludedLayouts includes, SparseIntArray viewsWithIds, boolean isRoot) {    ViewDataBinding existingBinding = getBinding(view);    if(existingBinding == null) {        Object objTag = view.getTag();        String tag = objTag instanceof String?(String)objTag:null;                if(isRoot &amp;&amp; tag != null &amp;&amp; tag.startsWith("layout")) {            // 如果是rootView，则从"layout/activity_main_0"中取出索引"0"，设置到bindings[0]中            viewGroup = tag.lastIndexOf(95);            count = parseTagInt(tag, viewGroup + 1);            if(bindings[count] == null) {                bindings[count] = view;            }            ...        } else if(tag != null &amp;&amp; tag.startsWith("binding_")) {            // 同样判断tag，取出"binding_1"，"bingding_2"中的索引，赋值到bindings[]中            viewGroup = parseTagInt(tag, BINDING_NUMBER_START);            if(bindings[viewGroup] == null) {                bindings[viewGroup] = view;            }            ...        }                // isBound=false，说明当前的view既不是根布局，也没有用到"@{}"（如果有用到就会生成"binding_"        // 的tag）；则通过id获取该view，并设置到bingding[]        // 如果存在设置了id，但是没有“@{}”的view会被添加到sViewsWithIds中，如果        // "binding_[index]"的index最大为3，则view的起始index设置为4。        // static {        //    sIncludes = null;        //    sViewsWithIds = new android.util.SparseIntArray();        //    sViewsWithIds.put(R.id.btn_test, 4);        //}        if(!isBound) {            viewGroup = view.getId();            if(viewGroup &gt; 0 &amp;&amp; viewsWithIds != null &amp;&amp; (count = viewsWithIds.get(viewGroup, -1)) &gt;= 0 &amp;&amp; bindings[count] == null) {                bindings[count] = view;            }        }        if(view instanceof ViewGroup) {            // 如果是view是个viewGroup，则遍历子view            ViewGroup var25 = (ViewGroup)view;            count = var25.getChildCount();            ...            for(int i = 0; i &lt; count; ++i) {                View child = var25.getChildAt(i);                boolean isInclude = false;                if(indexInIncludes &gt;= 0 &amp;&amp; child.getTag() instanceof String) {                    String childTag = (String)child.getTag();                    if(childTag.endsWith("_0") &amp;&amp; childTag.startsWith("layout") &amp;&amp; childTag.indexOf(47) &gt; 0) {                        // 如果当前view也是一个rootView，则判断tag中是否有include标识信息                        // 如果包含include标签，生成的info-layout文件应该是以下样式：                        // &lt;Target include="include_main" tag="layout/activity_main_0"&gt;                        // &lt;/Target&gt;                        int includeIndex = findIncludeIndex(childTag, minInclude, includes, indexInIncludes);                        if(includeIndex &gt;= 0) {                            isInclude = true;                            ...                            // 如果包含include信息，则重新调用DataBindingUtil.bind()生成ViewDataBinding，重复当前流程，                            // 不过当前的bindings[index]就不是一个view，而是一个viewDataBinding                            bindings[index] = DataBindingUtil.bind(bindingComponent, child, layoutId);                            ...                        }                    }                }                if(!isInclude) {                    // 如果只是一个viewGroup，不是include进来的布局，则重新调用mapBindings，只是isRoot=false，则会上面进入"binding_"的判断逻辑                    mapBindings(bindingComponent, child, bindings, includes, viewsWithIds, false);                }            }        }    }}#####view遍历流程图View都找到了，现在该是时候设置listener，data的时候了。这时候会通过invalidateAll()请求数据更新，层层调用后，还是回到了ActivityMainBinding的executeBindings()，在这个方法里将更新后的model数据，onclick等重新设置到Textview，Button上，完成了model-&gt;view的单向绑定。// 子类：xxxViewDataBinding extends ViewDataBindingpublic void invalidateAll() {    synchronized(this) {        this.mDirtyFlags = 4L;    }    this.requestRebind();}// 父类：ViewDataBinding.java// 通过handler.post()执行mRebindRunnableprotected void requestRebind() {    ...    mUIThreadHandler.post(mRebindRunnable);}// mRebindRunnable调用了executePendingBindings()private final Runnable mRebindRunnable = new Runnable() {    @Override    public void run() {        ...        executePendingBindings();    }};// executePendingBindings调用了executeBindings()public void executePendingBindings() {    ...    executeBindings();    ...}// 子类：xxxViewDataBinding extends ViewDataBindingprotected void executeBindings() {    ...    // 当调用ViewDataBinding.setUser(new User())时，就是给成员变量mUser赋值，在这里获取this.mUser    UserModel user = this.mUser;    if((dirtyFlags &amp; 6L) != 0L) {        // 获取并构建数据，所以model中的字段要么为public，要么提供一个getter方法，不然这里无法获取        // 可以看到，在xml中的@{}表达式，此时已经解析成对应的方法isAge18，user.name等        if(user != null) {            userIsAge18User = user.isAge18();            nameUser = user.name;            nickNameUser = user.nickName;        }        ...        // 获取并构建数据        userIsAge18UserStrin = userIsAge18User?"man":"boy";        stringNameUser = "名字" + nameUser;        ObjectnullNickNameUs1 = null == nickNameUser;        ...        objectnullNickNameUs = ObjectnullNickNameUs1?0:8;    }    // 设置listener    if((dirtyFlags &amp; 5L) != 0L) {        this.btnTest.setOnClickListener(testClick);    }    // 通过TextViewBindingAdapter将数据设置到TextView上    if((dirtyFlags &amp; 6L) != 0L) {        TextViewBindingAdapter.setText(this.mboundView1, stringNameUser);        TextViewBindingAdapter.setText(this.mboundView2, nickNameUser);        this.mboundView2.setVisibility(objectnullNickNameUs);        TextViewBindingAdapter.setText(this.mboundView3, userIsAge18UserStrin);    }}######以上便是当我们通过DataBindingUtil.setContentView()对Databinding进行初始化，以及当我们获取到最新数据，通过Binding.setModel进行数据更新时的操作流程。###参考英文官方文档https://developer.android.com/topic/libraries/data-binding/index.htmlGoogle开发团队介绍DataDinding使用https://realm.io/cn/news/data-binding-android-boyar-mount/?utm_source=tuicool&amp;utm_medium=referralQQ音乐团队分享，比较贴近源码的介绍http://gold.xitu.io/entry/57e48e7ba22b9d006139c60b]]></content>
      <categories>
        
          <category> android </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Github pages + Jekyll 搭建技术博客]]></title>
      <url>/android/2016/05/27/GithubPages+Jekyll%E6%90%AD%E5%BB%BA%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/</url>
      <content type="text"><![CDATA[初始化Github Pages  创建repository=username.github.io，username必须是github的username，不然后续可能会返回不到这个url  给这个repository创建默认的index.html    // clonegit clone https://github.com/listen2code/listen2code.github.io.git// create index.htmlcd listen2code.github.ioecho "Hello World" &gt; index.html// pushgit add --allgit commit -m "Initial commit"git push -u origin master        访问https://listen2code.github.io/  以上步骤参考Github Pages搭建，站点初步已经搭建好了，接下来就要改造index.html，使其可以展示首页，分类等常见博客页面组件，这里需要使用Github Pages官方推荐Jekyll静态网页生成工具。Step by Step to Jekyll环境搭建：由于Jekyll是用Ruby写的，所以先搭建Ruby环境（版本&gt;2.4.0）# 安装 Homebrew/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"# 安装 rubybrew install ruby# 将ruby path添加到环境变量中export PATH=/usr/local/opt/ruby/bin:$PATH# 重启terminal后，检查ruby安装情况which ruby# /usr/local/opt/ruby/bin/rubyruby -v# ruby 2.6.4p104 (2019-08-28 revision 67798) [x86_64-darwin18]  mac系统默认的ruby可能和Homebrew安装的ruby冲突，需要进行以下配置，使默认找到的ruby为Homebrew下载的最新版本。export PATH="/usr/local/opt/ruby/bin:$PATH"export LDFLAGS="-L/usr/local/opt/ruby/lib"export CPPFLAGS="-I/usr/local/opt/ruby/include"export PKG_CONFIG_PATH="/usr/local/opt/ruby/lib/pkgconfig"  安装jekyll：# 安装jekyllgem install jekyll bundler# 任意选择一个目录，例如：/Users/xx/，执行以下命令，会在该目录下生成Gemfile配置文件bundle init# Writing new Gemfile to /Users/xx/Gemfile  打开/Users/xx/Gemfile文件，将”gem jekyll”添加在末尾# frozen_string_literal: truesource "https://rubygems.org"git_source(:github) {|repo_name| "https://github.com/#{repo_name}" }# 添加在这里gem "jekyll"# 执行"bundle"，安装相关gem依赖，这里卡住会有点慢bundle# 省略...# Bundle complete! 1 Gemfile dependency, 28 gems now installed.# Use `bundle info [gemname]` to see where a bundled gem is installed.# 检查bundle执行结果bundle info jekyll#jekyll (4.0.0)#	Summary: A simple, blog aware, static site generator新建首页  新建个目录/User/xx/root，创建index.html&lt;!doctype html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;title&gt;Home&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;Hello World!&lt;/h1&gt;  &lt;/body&gt;&lt;/html&gt;# 进入到root目录cd /User/xx/rootbundle exec jekyll serve --trace# ...# Server address: http://127.0.0.1:4000# Server running... press ctrl-c to stop.# 执行"bundle exec"后，会在/User/xx/root/_site目录生成符合w3c标准的index.html文件，通过浏览器访问 http://127.0.0.1:4000，即可以看到显示"Hello World"的页面Liquid语法在html头部定义变量my_content，并可以在”{{}}”中使用Liquid表达式---my_content: Hello World!---&lt;!doctype html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;title&gt;Home&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;{{ page.my_content }}&lt;/h1&gt;  &lt;/body&gt;&lt;/html&gt;_layouts目录：用于存放布局模板文件新建”/User/xx/root/_layouts/default.html”：&lt;!doctype html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;title&gt;{{ page.title }}&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    {{ content }}  &lt;/body&gt;&lt;/html&gt;修改index.html，设置layout=default，相当于将index的文本内容include到default.html的”{{content}}”标签内，可以通过在_layout目录下定义布局模板，供其他页面引用，实现布局样式的统一：---layout: defaulttitle: Home---&lt;h1&gt;"Hello World!"&lt;/h1&gt;_includes目录：用于存放可以复用的组件新建”/User/xx/root/_includes/navigation.html”，设置导航栏的链接&lt;nav&gt;  &lt;a href="/"&gt;Home&lt;/a&gt;  &lt;a href="/about.html"&gt;About&lt;/a&gt;&lt;/nav&gt;修改default.html，通过include表达式将导航栏添加在布局模板中&lt;!doctype html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;title&gt;{{ page.title }}&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    {% include navigation.html %}    {{ content }}  &lt;/body&gt;&lt;/html&gt;_data目录：存放数据新建”/User/xx/root/_data/navigation.yml”，Jekyll默认将生成site.data.navigation数据集合- name: Home  link: /- name: About  link: /about.html修改navigation.html，遍历site.data.navigation生成a标签&lt;nav&gt;  {% for item in site.data.navigation %}    &lt;a href="{{ item.link }}"&gt;      {{ item.name }}    &lt;/a&gt;  {% endfor %}&lt;/nav&gt;_posts目录：存放blog文件的目录新建”/User/xx/root/_posts/2019-1-1-blog1.html”，与_data目录同理，Jekyll将会在/User/xx/root/_site目录下生成”2019/01/01/blog1.html”---layout: postauthor: listen---this is blog1新建”/User/xx/root/_layouts/post.html”，专门用于显示blog的布局模板---layout: default---&lt;h1&gt;{{ page.title }}&lt;/h1&gt;&lt;p&gt;{{ page.date | date_to_string }} - {{ page.author }}&lt;/p&gt;{{ content }}新建”/User/xx/root/blog_list.html”，用于展示_posts目录下的blog列表---layout: defaulttitle: Blog---&lt;ul&gt;  {% for post in site.posts %}    &lt;li&gt;      &lt;h2&gt;&lt;a href="{{ post.url }}"&gt;{{ post.title }}&lt;/a&gt;&lt;/h2&gt;    &lt;/li&gt;  {% endfor %}&lt;/ul&gt;发布：将_site目录下的内容拷贝到github的username.github.io目录下即可完成发布jekyllthemes快速搭建  可以在jekyllthemes，选择一个现成的jekyllthemes完成快速搭建  选择themes模板NexT，并下载zip  解压后获得jekyll-theme-next-master目录  cd jekyll-theme-next-master，执行”bundle”下载相关gem依赖  根据使用教程修改jekyll-theme-next-master/_config.yml完成页面基础设置，如：页面组件布局，主题，头像，分类目录等  将blog文件放置在_posts目录下  cd jekyll-theme-next-master，执行”bundle exec jekyll serve –trace”，生成_site目录  将_site目录下的内容拷贝到listen2code.github.io的localpath，并同步到github  访问https://listen2code.github.io]]></content>
      <categories>
        
          <category> android </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Next Theme Tutorial]]></title>
      <url>/tutorial/2015/12/25/next-tutorial/</url>
      <content type="text"><![CDATA[  NexT is a high quality elegant Jekyll theme ported from Hexo Next. It is crafted from scratch, with love.Live PreviewScreenshots      Desktop        Sidebar    Sidebar (Post details page)  MobileInstallationCheck whether you have Ruby 2.1.0 or higher installed:ruby --versionInstall Bundler:gem install bundlerClone Jacman theme:git clone https://github.com/Simpleyyt/jekyll-theme-next.gitcd jekyll-theme-nextInstall Jekyll and other dependencies from the GitHub Pages gem:bundle installRun your Jekyll site locally:bundle exec jekyll serverMore Details：Setting up your GitHub Pages site locally with JekyllFeaturesMultiple languages support, including: English / Russian / French / German / Simplified Chinese / Traditional Chinese.Default language is English.language: en# language: zh-Hans# language: fr-FR# language: zh-hk# language: zh-tw# language: ru# language: deSet language field as following in site _config.yml to change to Chinese.language: zh-HansComment support.NexT has native support for DuoShuo and Disqus comment systems.Add the following snippets to your _config.yml:duoshuo:  enable: true  shortname: your-duoshuo-shortnameORdisqus_shortname: your-disqus-shortnameSocial MediaNexT can automatically add links to your Social Media accounts:social:  GitHub: your-github-url  Twitter: your-twitter-url  Weibo: your-weibo-url  DouBan: your-douban-url  ZhiHu: your-zhihu-urlFeed link.  Show a feed link.Set rss field in theme’s _config.yml, as the following value:  rss: false will totally disable feed link.      rss:   use sites’ feed link. This is the default option.    Follow the installation instruction in the plugin’s README. After the configuration is done for this plugin, the feed link is ready too.    rss: http://your-feed-url set specific feed link.Up to 5 code highlight themes built-in.NexT uses Tomorrow Theme with 5 themes for you to choose from.Next use normal by default. Have a preview about normal and night:Head over to Tomorrow Theme for more details.ConfigurationNexT comes with few configurations.# Menu configuration.menu:  home: /  archives: /archives# Faviconfavicon: /favicon.ico# Avatar (put the image into next/source/images/)# can be any image format supported by web browsers (JPEG,PNG,GIF,SVG,..)avatar: /default_avatar.png# Code highlight theme# available: normal | night | night eighties | night blue | night brighthighlight_theme: normal# Fancybox for image galleryfancybox: true# Specify the date when the site was setupsince: 2013Browser support]]></content>
      <categories>
        
          <category> tutorial </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MathJax with Jekyll]]></title>
      <url>/opinion/2015/12/24/Mathjax-with-jekyll/</url>
      <content type="text"><![CDATA[One of the rewards of switching my website to Jekyll is theability to support MathJax, which means I can write LaTeX-like equations that getnicely displayed in a web browser, like this one \( \sqrt{\frac{n!}{k!(n-k)!}} \) orthis one \( x^2 + y^2 = r^2 \).What’s MathJax?If you check MathJax website (www.mathjax.org) you’ll seethat it is an open source JavaScript display engine for mathematics that works in allbrowsers.How to implement MathJax with JekyllI followed the instructions described by Dason Kurkiewicz forusing Jekyll and Mathjax.Here are some important details. I had to modify the Ruby library for Markdown inmy _config.yml file. Now I’m using redcarpet so the corresponding line in theconfiguration file is: markdown: redcarpetTo load the MathJax javascript, I added the following lines in my layout post.html(located in my folder _layouts)&lt;script type="text/javascript"    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt;Of course you can choose a different file location in your jekyll layouts.Note that by default, the tex2jax preprocessor defines theLaTeX math delimiters, which are \\(...\\) for in-line math, and \\[...\\] fordisplayed equations. It also defines the TeX delimiters $$...$$ for displayedequations, but it does not define $...$ as in-line math delimiters. To enable in-line math delimiter with $...$, please use the following configuration:&lt;script type="text/x-mathjax-config"&gt;MathJax.Hub.Config({  tex2jax: {    inlineMath: [['$','$'], ['\\(','\\)']],    processEscapes: true  }});&lt;/script&gt;&lt;script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"&gt;&lt;/script&gt;A Couple of ExamplesHere’s a short list of examples. To know more about the details behind MathJax, you canalways checked the provided documentation available athttp://docs.mathjax.org/en/latest/Let’s try a first example. Here’s a dummy equation:How do you write such expression? Very simple: using double dollar signs$$a^2 + b^2 = c^2$$To display inline math use \\( ... \\) like this \\( sin(x^2) \\) which getsrendered as \( sin(x^2) \)Here’s another example using type \mathsf$$ \mathsf{Data = PCs} \times \mathsf{Loadings} $$which gets displayed asOr even better:\\[ \mathbf{X} = \mathbf{Z} \mathbf{P^\mathsf{T}} \\]is displayed as\[ \mathbf{X} = \mathbf{Z} \mathbf{P^\mathsf{T}} \]If you want to use subscripts like this \( \mathbf{X}_{n,p} \) you need to scape theunderscores with a backslash like so \mathbf{X}\_{n,p}:$$ \mathbf{X}\_{n,p} = \mathbf{A}\_{n,k} \mathbf{B}\_{k,p} $$will be displayed as\[ \mathbf{X}_{n,p} = \mathbf{A}_{n,k} \mathbf{B}_{k,p} \]]]></content>
      <categories>
        
          <category> opinion </category>
        
      </categories>
      <tags>
        
          <tag> resources </tag>
        
          <tag> jekyll </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Elements]]></title>
      <url>/foo/2015/12/23/elements/</url>
      <content type="text"><![CDATA[The purpose of this post is to help you make sure all of HTML elements can display properly. If you use CSS reset, don’t forget to redefine the style by yourself.Heading 1Heading 2Heading 3Heading 4Heading 5Heading 6ParagraphLorem ipsum dolor sit amet, test link consectetur adipiscing elit. Strong text pellentesque ligula commodo viverra vehicula. Italic text at ullamcorper enim. Morbi a euismod nibh. Underline text non elit nisl. Deleted text tristique, sem id condimentum tempus, metus lectus venenatis mauris, sit amet semper lorem felis a eros. Fusce egestas nibh at sagittis auctor. Sed ultricies ac arcu quis molestie. Donec dapibus nunc in nibh egestas, vitae volutpat sem iaculis. Curabitur sem tellus, elementum nec quam id, fermentum laoreet mi. Ut mollis ullamcorper turpis, vitae facilisis velit ultricies sit amet. Etiam laoreet dui odio, id tempus justo tincidunt id. Phasellus scelerisque nunc sed nunc ultricies accumsan.Interdum et malesuada fames ac ante ipsum primis in faucibus. Sed erat diam, blandit eget felis aliquam, rhoncus varius urna. Donec tellus sapien, sodales eget ante vitae, feugiat ullamcorper urna. Praesent auctor dui vitae dapibus eleifend. Proin viverra mollis neque, ut ullamcorper elit posuere eget.  Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna.Maecenas ornare arcu at mi suscipit, non molestie tortor ultrices. Aenean convallis, diam et congue ultricies, erat magna tincidunt orci, pulvinar posuere mi sapien ac magna. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Praesent vitae placerat mauris. Nullam laoreet ante posuere tortor blandit auctor. Sed id ligula volutpat leo consequat placerat. Mauris fermentum dolor sed augue malesuada sollicitudin. Vivamus ultrices nunc felis, quis viverra orci eleifend ut. Donec et quam id urna cursus posuere. Donec elementum scelerisque laoreet.List TypesDefinition List (dl)Definition List TitleThis is a definition list division.Ordered List (ol)  List Item 1  List Item 2  List Item 3Unordered List (ul)  List Item 1  List Item 2  List Item 3Table            Table Header 1      Table Header 2      Table Header 3                  Division 1      Division 2      Division 3              Division 1      Division 2      Division 3              Division 1      Division 2      Division 3      Misc Stuff - abbr, acronym, sub, sup, etc.Lorem superscript dolor subscript amet, consectetuer adipiscing elit. Nullam dignissim convallis est. Quisque aliquam. cite. Nunc iaculis suscipit dui. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus. Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. NBA Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus.  AVE]]></content>
      <categories>
        
          <category> Foo </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Gallery Post]]></title>
      <url>/photo/2015/12/22/gallery-post/</url>
      <content type="text"><![CDATA[Nunc dignissim volutpat enim, non sollicitudin purus dignissim id. Nam sit amet urna eu velit lacinia eleifend. Proin auctor rhoncus ligula nec aliquet. Donec sodales molestie lacinia. Curabitur dictum faucibus urna at convallis. Aliquam in lectus at urna rutrum porta. In lacus arcu, molestie ut vestibulum ut, rhoncus sed eros. Sed et elit vitae risus pretium consectetur vel in mi. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi tempus turpis quis lectus rhoncus adipiscing. Proin pulvinar placerat suscipit. Maecenas imperdiet, quam vitae varius auctor, enim mauris vulputate sapien, nec laoreet neque diam non quam.Etiam luctus mauris at mi sollicitudin quis malesuada nibh porttitor. Vestibulum non dapibus magna. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Proin feugiat hendrerit viverra. Phasellus sit amet nunc mauris, eu ultricies tellus. Sed a mi tortor, eleifend varius erat. Proin consectetur molestie tortor eu gravida. Cras placerat orci id arcu tristique ut rutrum justo pulvinar. Maecenas lacinia fringilla diam non bibendum. Aenean vel viverra turpis. Integer ut leo nisi. Pellentesque vehicula quam ut sapien convallis consequat. Aliquam ut arcu purus, eget tempor purus. Integer eu tellus quis erat tristique gravida eu vel lorem.]]></content>
      <categories>
        
          <category> Photo </category>
        
      </categories>
      <tags>
        
          <tag> consectetur </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[中文測試]]></title>
      <url>/test/test/2015/12/21/%E4%B8%AD%E6%96%87%E6%B8%AC%E8%A9%A6/</url>
      <content type="text"><![CDATA[This is a Chinese test post.善我王上魚、產生資西員合兒臉趣論。畫衣生這著爸毛親可時，安程幾？合學作。觀經而作建。都非子作這！法如言子你關！手師也。以也座論頭室業放。要車時地變此親不老高小是統習直麼調未，行年香一？就竟在，是我童示讓利分和異種百路關母信過明驗有個歷洋中前合著區亮風值新底車有正結，進快保的行戰從：弟除文辦條國備當來際年每小腳識世可的的外的廣下歌洲保輪市果底天影；全氣具些回童但倒影發狀在示，數上學大法很，如要我……月品大供這起服滿老？應學傳者國：山式排只不之然清同關；細車是！停屋常間又，資畫領生，相們制在？公別的人寫教資夠。資再我我！只臉夫藝量不路政吃息緊回力之；兒足灣電空時局我怎初安。意今一子區首者微陸現際安除發連由子由而走學體區園我車當會，經時取頭，嚴了新科同？很夫營動通打，出和導一樂，查旅他。坐是收外子發物北看蘭戰坐車身做可來。道就學務。國新故。  工步他始能詩的，裝進分星海演意學值例道……於財型目古香亮自和這乎？化經溫詩。只賽嚴大一主價世哥受的沒有中年即病行金拉麼河。主小路了種就小為廣不？From 亂數假文產生器 - Chinese Lorem Ipsum]]></content>
      <categories>
        
          <category> test/test </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[日本語テスト]]></title>
      <url>/2015/12/20/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%83%86%E3%82%B9%E3%83%88/</url>
      <content type="text"><![CDATA[This is a Japanese test post.私は昨日ついにその助力家というのの上よりするたなけれ。最も今をお話団はちょうどこの前後なかろでくらいに困りがいるたをは帰着考えたなかって、そうにもするでうたらない。がたを知っないはずも同時に九月をいよいよたありた。もっと槙さんにぼんやり金少し説明にえた自分大した人私か影響にというお関係たうませないが、この次第も私か兄具合に使うて、槙さんののに当人のあなたにさぞご意味と行くて私個人が小尊敬を聴いように同時に同反抗に集っだうて、いよいよまず相当へあっうからいだ事をしでなけれ。  それでそれでもご時日をしはずはたったいやと突き抜けるますて、その元がは行ったてという獄を尽すていけですた。この中道具の日その学校はあなたごろがすまなりかとネルソンさんの考えるですん、辺の事実ないというご盲従ありたですと、爺さんのためが薬缶が結果までの箸の当時してならて、多少の十月にためからそういう上からとにかくしましないと触れべきものたで、ないうですと多少お人達したのでたた。From すぐ使えるダミーテキスト - 日本語 Lorem ipsum]]></content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Excerpts]]></title>
      <url>/2015/12/19/excerpts/</url>
      <content type="text"><![CDATA[The following contents should be invisible in home/archive page.Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce eget urna vitae velit eleifend interdum at ac nisi. In nec ligula lacus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Sed eu cursus erat, ut dapibus quam. Aliquam eleifend dolor vitae libero pharetra adipiscing. Etiam adipiscing dolor a quam tempor, eu convallis nulla varius. Aliquam sollicitudin risus a porta aliquam. Ut nec velit dolor. Proin eget leo lobortis, aliquam est sed, mollis mauris. Fusce vitae leo pretium massa accumsan condimentum. Fusce malesuada gravida lectus vel vulputate. Donec bibendum porta nibh ut aliquam.Sed lorem felis, congue non fringilla eu, aliquam eu eros. Curabitur orci libero, mollis sed semper vitae, adipiscing in lectus. Aenean non egestas odio. Donec sollicitudin nisi quis lorem gravida, in pharetra mauris fringilla. Duis sit amet faucibus dolor, id aliquam neque. In egestas, odio gravida tempor dictum, mauris felis faucibus purus, sit amet commodo lacus diam vitae est. Ut ut quam eget massa semper sodales. Aenean non ipsum cursus, blandit lectus in, ornare odio. Curabitur ultrices porttitor vulputate.]]></content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Block]]></title>
      <url>/foo/2015/12/18/block/</url>
      <content type="text"><![CDATA[This post is used for testing tag plugins. See docs for more info.Block QuoteNormal blockquote  Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna.Code BlockInline code blockThis is a inline code block: python, print 'helloworld'.Normal code blockalert('Hello World!');print "Hello world"Highlight code blockprint "Hello world"def foo  puts 'foo'end123def foo  puts 'foo'endGist]]></content>
      <categories>
        
          <category> Foo </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Highlight Test]]></title>
      <url>/test/2015/12/17/highlight-test/</url>
      <content type="text"><![CDATA[This is a highlight test.Normal blockalert('Hello World!');print 'helloworld'Highlight blockalert( 'Hello, world!' );print 'helloworld'def foo  puts 'foo'enddef foo  puts 'foo'end123def foo  puts 'foo'end#include &lt;iostream&gt;using namespace std;void foo(int arg1, int arg2){}int main(){  string str;  foo(1, 2);  cout &lt;&lt; "Hello World" &lt;&lt; endl;  return 0;}]]></content>
      <categories>
        
          <category> Test </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Images]]></title>
      <url>/2015/12/16/images/</url>
      <content type="text"><![CDATA[This is a image test post.]]></content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Emoji Test]]></title>
      <url>/2015/12/15/emoji-test/</url>
      <content type="text"><![CDATA[This is an emoji test. :smile: lol.See emoji cheat sheet for more detail :wink: : https://www.webpagefx.com/tools/emoji-cheat-sheet/.:bowtie::smile::laughing::blush::smiley::relaxed::smirk::heart_eyes::kissing_heart::kissing_closed_eyes::flushed::relieved::satisfied::grin:]]></content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam justo turpis, tincidunt ac convallis id.]]></title>
      <url>/foo/2015/12/14/long-title/</url>
      <content type="text"><![CDATA[This post has a long title. Make sure the title displayed right.]]></content>
      <categories>
        
          <category> Foo </category>
        
      </categories>
      <tags>
        
          <tag> Foo </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Link Post]]></title>
      <url>/foo/2015/12/13/link-post/</url>
      <content type="text"><![CDATA[This is a link post. Clicking on the link should open Google in a new tab or window.]]></content>
      <categories>
        
          <category> Foo </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Categories]]></title>
      <url>/foo/bar/baz/2015/12/12/categories/</url>
      <content type="text"><![CDATA[This post contains 3 categories. Make sure your theme can display all of the categories.]]></content>
      <categories>
        
          <category> Foo </category>
        
          <category> Bar </category>
        
          <category> Baz </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Tags]]></title>
      <url>/foo/2015/12/11/tags/</url>
      <content type="text"><![CDATA[This post contains 3 tags. Make sure your theme can display all of the tags.]]></content>
      <categories>
        
          <category> Foo </category>
        
      </categories>
      <tags>
        
          <tag> Foo </tag>
        
          <tag> Bar </tag>
        
          <tag> Baz </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
